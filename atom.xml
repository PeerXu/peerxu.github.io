<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Tom Preston-Werner</title>
 <link href="http://peerxu.github.com/blog/atom.xml" rel="self"/>
 <link href="http://peerxu.github.com/blog/"/>
 <updated>2014-07-08T12:05:32+08:00</updated>
 <id>http://peerxu.github.com/blog/</id>
 <author>
   <name>Peer Xu</name>
   <email>pppeerxu@gmail.com</email>
 </author>

 
 <entry>
   <title>老板, 要挑个号码么?</title>
   <link href="http://tom.preston-werner.com/2014/07/08/choose-your-favorite-number-from-alibaba.html"/>
   <updated>2014-07-08T00:00:00+08:00</updated>
   <id>http://peerxu.github.com//2014/07/08/choose-your-favorite-number-from-alibaba</id>
   <content type="html">&lt;h1&gt;老板, 要挑个号码么?&lt;/h1&gt;

&lt;p&gt;0x00&lt;/p&gt;

&lt;p&gt;注意: 本文仅仅探讨技术, 读者任何行为与本文无关
注意: 本文探讨技术已经通过正规渠道报告&lt;/p&gt;

&lt;p&gt;0x01&lt;/p&gt;

&lt;p&gt;本文讲的是如何在阿里移动中随意挑选喜好的号码&lt;/p&gt;

&lt;p&gt;0x02&lt;/p&gt;

&lt;p&gt;挑选的几个条件:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;号码必须存在阿里移动后台&lt;/li&gt;
&lt;li&gt;号码必须没有被被的用户购买&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;0x03&lt;/p&gt;

&lt;p&gt;改dom大法&lt;/p&gt;

&lt;p&gt;0x04&lt;/p&gt;

&lt;p&gt;enjoy yourself.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Google IP Explorer使用教程</title>
   <link href="http://tom.preston-werner.com/2014/07/03/google-ip-explorer-tutorial.html"/>
   <updated>2014-07-03T00:00:00+08:00</updated>
   <id>http://peerxu.github.com//2014/07/03/google-ip-explorer-tutorial</id>
   <content type="html">&lt;h1&gt;Google IP Explorer使用教程&lt;/h1&gt;

&lt;h2&gt;教程&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/PeerXu/google-ip-explorer&quot;&gt;Google IP Explorer&lt;/a&gt;是一个查找Google IP列表的工具. 可以单独使用, 也可以配合Goagent使用.&lt;/p&gt;

&lt;p&gt;如果已经安装了gevent库, 那么可以大大地增加查找速度.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/PeerXu/google-ip-explorer.git
$ cd google-ip-explorer
$ python google.py input.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Google IP列表就在output.txt文件中.&lt;/p&gt;

&lt;p&gt;如果你需要直接使用, 那么就挑一个IP直接在浏览器里面就能使用了.&lt;/p&gt;

&lt;p&gt;如果你需要和Goagent配合使用的话, 那么就将&lt;code&gt;proxy.ini&lt;/code&gt; 下的&lt;code&gt;[iplist]&lt;/code&gt; 下的&lt;code&gt;google_cn&lt;/code&gt; 和 &lt;code&gt;google_hk&lt;/code&gt; 替换为output.txt的内容就可以了~&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>在浏览器中调用RESTful API Service</title>
   <link href="http://tom.preston-werner.com/2014/06/12/send-request-to-restful-api-service-from-browser.html"/>
   <updated>2014-06-12T00:00:00+08:00</updated>
   <id>http://peerxu.github.com//2014/06/12/send-request-to-restful-api-service-from-browser</id>
   <content type="html">&lt;h1&gt;在浏览器中调用RESTful API Service&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;以下内容请自备梯子&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/REST&quot;&gt;RESTful&lt;/a&gt; API Service是以REST风格提供的API Service.&lt;/p&gt;

&lt;p&gt;通常情况下会采用到HTTP的GET, POST, DELETE, PUT等方法.&lt;/p&gt;

&lt;p&gt;因为浏览器的正常访问手段(直接通过连接访问或Form提交), 无法向Service发起DELETE, PUT等方法的请求.&lt;/p&gt;

&lt;p&gt;所以只能通过&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;对象来提供完整交互操作.&lt;/p&gt;

&lt;p&gt;那么最后的问题就回归到, 如果使用&lt;code&gt;XMLHttpRequest&lt;/code&gt;对象上了.&lt;/p&gt;

&lt;p&gt;参考上面给出的&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;的链接, 我们学习到使用方法.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// javascript
var xhr = new XMLHttpRequest();
xhr.open(&quot;DELETE&quot;, &quot;http://localhost:8888/messages/1&quot;);
xhr.send();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面就是&lt;code&gt;XMLHttpRequest&lt;/code&gt;的简单使用方法. 当然, 这里只是发送了, 并完成后续的处理. 我们现在只关心发送.&lt;/p&gt;

&lt;p&gt;那么在这里也奉上Server端的源代码.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#! /usr/bin/env python2.7
# filename: app.py

from flask import Flask, make_response

app = Flask(__name__)

@app.route('/messages/&amp;lt;int:msg_id&amp;gt;', methods=['DELETE'])
def delete_message(msg_id):
  return 'delete message #%s' % msg_id

app.run(debug=True, port=8888)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面就是服务端的代码.&lt;/p&gt;

&lt;p&gt;但是通过浏览器console发起请求的时候, 我们可以观察到一下错误提示:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;OPTIONS http://localhost:8888/messages/1 No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'https://developer.mozilla.org' is therefore not allowed access.
XMLHttpRequest cannot load http://localhost:8888/messages/1. No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'https://developer.mozilla.org' is therefore not allowed access.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两行错误提示表明, 我们需要在服务端上, 在返回&lt;code&gt;Response&lt;/code&gt;对象时候, 在&lt;code&gt;Response Header&lt;/code&gt;上提供&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;字段.&lt;/p&gt;

&lt;p&gt;并且通过Chrome Developer Tools的Network中观察到, &lt;code&gt;XMLHttpRequest&lt;/code&gt;会发送HTTP的&lt;code&gt;OPTIONS&lt;/code&gt; Request到服务端上. 通过这次Request的Response的&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;和&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;这两个字段来决定, xhr是否有对该域发起请求的权限.&lt;/p&gt;

&lt;p&gt;其中, &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;字段代表的是, 是否允许本域向API Service发起请求. &lt;code&gt;*&lt;/code&gt;代表所有域都能发起请求.&lt;/p&gt;

&lt;p&gt;而&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;则代表的允许请求的方法有那些.&lt;/p&gt;

&lt;p&gt;那么这时我们就&lt;strong&gt;将就地&lt;/strong&gt;添加&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;字段为&lt;code&gt;*&lt;/code&gt; **(注意: 请在生产环境中谨慎添加允许跨域的主机), 添加&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;字段为&lt;code&gt;POST,DELETE,PUT,GET&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;再次修改服务端代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#! /usr/bin/env python2.7
# filename: app.py

from flask import Flask, make_response

app = Flask(__name__)

@app.route('/messages/&amp;lt;int:msg_id&amp;gt;', methods=['OPTIONS'])
def options_message(msg_id):
  resp = make_response('')
  resp.headers.extend({
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'POST,DELETE,PUT,GET'
  })
  return resp

@app.route('/messages/&amp;lt;int:msg_id&amp;gt;', methods=['DELETE'])
def delete_message(msg_id):
  resp = make_response('delete message #%s' % msg_id)
  resp.headers['Access-Control-Allow-Origin'] = '*'
  return resp

app.run(debug=True, port=8888)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;OPTIONS&lt;/code&gt;处理函数中, 添加Response Header的&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;和&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;字段. 来声明权限和允许的方法.&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;DELETE&lt;/code&gt;处理函数中, 添加&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;字段来声明权限.&lt;/p&gt;

&lt;p&gt;that's all.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>采用Flask-Restful插件返回Javascript脚本的两种方法</title>
   <link href="http://tom.preston-werner.com/2014/06/09/response-javascript-with-flask-restful-api.html"/>
   <updated>2014-06-09T00:00:00+08:00</updated>
   <id>http://peerxu.github.com//2014/06/09/response-javascript-with-flask-restful-api</id>
   <content type="html">&lt;h1&gt;采用Flask-Restful插件返回Javascript脚本的两种方法&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/mitsuhiko/flask&quot;&gt;Flask&lt;/a&gt; 是Python的一个轻量级的Web框架.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/twilio/flask-restful&quot;&gt;Flask-Restful&lt;/a&gt; 是将Flask应用构建为Restful API的一个插件.&lt;/p&gt;

&lt;p&gt;一个Flask-Restful插件的demo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat app.py
#! /usr/bin/env python2.7
# filename: app.py

from flask import Flask
from flask.ext.restful import Api, Resource

app = Flask(__name__)
api = Api(app)

class User(Resource):
  def get(self, user_id):
    return {'user_id': user_id}

api.add_resource(User, '/users/&amp;lt;int:user_id&amp;gt;')

if __name__ == '__main__':
  app.run(port=8888, debug=True)

$ python app.py
 * Running on http://127.0.0.1:8888/
 * Restarting with reloader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们可以看见Flask Demo已经成功运行.&lt;/p&gt;

&lt;p&gt;我们可以通过&lt;code&gt;curl&lt;/code&gt;这个工具来进行简单测试.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -v http://localhost:8888/users/1
* Adding handle: conn: 0x22f5a40
* Adding handle: send: 0
* Adding handle: recv: 0
* Curl_addHandleToPipeline: length: 1
* - Conn 0 (0x22f5a40) send_pipe: 1, recv_pipe: 0
* About to connect() to localhost port 8888 (#0)
*   Trying 127.0.0.1...
* Connected to localhost (127.0.0.1) port 8888 (#0)
&amp;gt; GET /users/1 HTTP/1.1
&amp;gt; User-Agent: curl/7.32.0
&amp;gt; Host: localhost:8888
&amp;gt; Accept: */*
&amp;gt;
* HTTP 1.0, assume close after body
&amp;lt; HTTP/1.0 200 OK
&amp;lt; Content-Type: application/json
&amp;lt; Content-Length: 21
&amp;lt; Server: Werkzeug/0.9.4 Python/2.7.5+
&amp;lt; Date: Mon, 09 Jun 2014 15:25:42 GMT
&amp;lt;
{
    &quot;user_id&quot;: 1
}
* Closing connection 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;curl的Response部分, 包含了一些信息.&lt;/p&gt;

&lt;p&gt;其中Content-Type字段表示的是, 返回的内容是json格式的.&lt;/p&gt;

&lt;p&gt;如果我们需要返回的值是javascript脚本的话, 那么我们就需要对demo进行一些改造.&lt;/p&gt;

&lt;p&gt;有两种办法:&lt;/p&gt;

&lt;h3&gt;1. 通过Flask的make_response函数&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ cat app.py
#! /usr/bin/env python2.7
# filename: app.py

import simplejson as json
from flask import Flask, make_response
from flask.ext.restful import Api, Resource

app = Flask(__name__)
api = Api(app)

class User(Resource):
  def get(self, user_id):
    user = {'user_id': user_id}
    data = json.dumps(user)
    response = make_response(data)
    response.headers.extend({
      'Content-Type': 'application/javascript'
    })
    return response

api.add_resource(User, '/users/&amp;lt;int:user_id&amp;gt;')

if __name__ == '__main__':
  app.run(port=8888, debug=True)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加Content-Type字段到response的headers中, 可以将返回的内容类型设置为javascript.&lt;/p&gt;

&lt;h3&gt;2. 通过Request Headers限制Response类型&lt;/h3&gt;

&lt;p&gt;HTTP协议中规定, 在Request Header中指定Accept字段, 可以指定客户端接受的Response类型.&lt;/p&gt;

&lt;p&gt;例如在curl中指定Accept字段:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -H 'Accept: application/javascript' http://localhost:8888/users/1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是在Flask-Restful插件中, 貌似是不支持javascript作为返回值类型.&lt;/p&gt;

&lt;p&gt;所以我们需要做一些patch.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#! /usr/bin/env python2.7
# filename: app.py

import simplejson as json
from flask import Flask, make_response
from flask.ext.restful import Api, Resource

# monkey patch: application/javascript mimetype

from flask.ext import restful
def output_javascript(data, code, headers=None):
  response = make_response(data, code)
  response.headers.extend(headers or {})
  return response

restful.DEFAULT_REPRESENTATIONS['application/javascript'] = output_javascript

# end monkey patch

app = Flask(__name__)
api = Api(app)

class User(Resource):
  def get(self, user_id):
    return {'user_id': user_id}

api.add_resource(User, '/users/&amp;lt;int:user_id&amp;gt;')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种方式显得更加优雅.&lt;/p&gt;

&lt;p&gt;但是需要在发起Request的时候设置Request Header的&lt;code&gt;Accept&lt;/code&gt;字段为&lt;code&gt;application/javascript&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;the end.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>从主机复制文件到Docker的几种方法</title>
   <link href="http://tom.preston-werner.com/2014/05/23/copy-file-from-host-to-docker.html"/>
   <updated>2014-05-23T00:00:00+08:00</updated>
   <id>http://peerxu.github.com//2014/05/23/copy-file-from-host-to-docker</id>
   <content type="html">&lt;h1&gt;从主机复制文件到Docker的几种方法&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.docker.io&quot;&gt;Docker&lt;/a&gt;是个Linux Container管理软件.&lt;/p&gt;

&lt;p&gt;今天我们来讲解一下从主机复制文件到Docker的几种方法.&lt;/p&gt;

&lt;p&gt;在分享之前, 我们看看Docker社区对这个&lt;a href=&quot;https://github.com/dotcloud/docker/issues/905&quot;&gt;问题&lt;/a&gt;的需求是有多么强(ju)烈(jin).&lt;/p&gt;

&lt;p&gt;下面开始今天高(tu)大(yuan)上(fei)的分享.&lt;/p&gt;

&lt;h3&gt;1. 通过Build Docker Image添加文件&lt;/h3&gt;

&lt;p&gt;Docker Image是通过Dockerfile来创建的. 具体的创建过程可以参考&lt;a href=&quot;https://www.docker.io/learn/dockerfile/&quot;&gt;这里&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;我们可以在编写Dockerfile的时候, 将需要的文件通过 &lt;code&gt;ADD&lt;/code&gt; 关键字添加文件到Docker Image里面.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM 3scale/openresty

## add your supervisor openresty config
ADD openresty.conf /etc/supervisor/conf.d/

# Add your app
ADD . /var/www

CMD [&quot;supervisor&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引用自 &lt;a href=&quot;https://index.docker.io/u/3scale/openresty/&quot;&gt;3scale/openresty&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这个Dockerfile中的&lt;code&gt;ADD&lt;/code&gt; 关键字是将本机添加到Docker Image中的&lt;code&gt;/var/www&lt;/code&gt; 文件夹中.&lt;/p&gt;

&lt;h3&gt;2. 通过docker run命令的-v/--volume参数&lt;/h3&gt;

&lt;p&gt;假设我们需要将本机的/data 目录分享到Docker的/mnt 目录下, 我们可以通过这样的命令:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ touch /data/bilibala
$ docker run -v /data:/mnt -i -t ubuntu bash
root@c039a83c35d0:/# ls /mnt
bilibala
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个命令可以在启动container中绑定文件夹.&lt;/p&gt;

&lt;h3&gt;3. 通过API绑定目录&lt;/h3&gt;

&lt;p&gt;其实这个方法本质上跟2是一样的, 但是唯一不同的就是, API将&lt;code&gt;docker run&lt;/code&gt; 这个命令分成两步了, 分别是: &lt;code&gt;create_container&lt;/code&gt; 和 &lt;code&gt;start&lt;/code&gt;
在&lt;code&gt;create_container&lt;/code&gt; 中, 通过&lt;code&gt;volumes&lt;/code&gt; 参数定义需要挂载的目录.
在&lt;code&gt;start&lt;/code&gt; 中, &lt;code&gt;binds&lt;/code&gt; 参数绑定.&lt;/p&gt;

&lt;p&gt;下面是一个简单的example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python2.7
import docker
c = docker.Client()

container = c.create_container('ubunt',
                               command='bash', volumes=['/mnt'],
                               tty=True, stdin_open=True)

c.start(container['Id'], binds={'/data':'/mnt'})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里就创建了一个挂载了&lt;code&gt;/data&lt;/code&gt;目录的container.&lt;/p&gt;

&lt;h3&gt;4. 通过环境变量传递文件&lt;/h3&gt;

&lt;p&gt;这个是我自己发明的小技巧, 因为在利用&lt;code&gt;volumes&lt;/code&gt; 参数的时候, 发现docker有些不稳定. 经常无法删除. 所以就通过创建的时候通过环境变量传输文件.&lt;/p&gt;

&lt;p&gt;先将文件通过&lt;code&gt;base64&lt;/code&gt;编码, 然后通过&lt;code&gt;create_container&lt;/code&gt; 方法的 &lt;code&gt;environment&lt;/code&gt;参数传递变量到container中, 在container中再解码放入到合适的路径下即可.&lt;/p&gt;

&lt;h3&gt;5. 总结&lt;/h3&gt;

&lt;p&gt;总的来说, 有三种不同的方式, 将host中的文件传递到container.&lt;/p&gt;

&lt;p&gt;分别是:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;创建Image时, 添加文件到Image&lt;/li&gt;
&lt;li&gt;创建Container时, 通过volumes参数传递文件&lt;/li&gt;
&lt;li&gt;创建Container时, 通过environment参数传递文件&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>pipework -- docker网络增强工具</title>
   <link href="http://tom.preston-werner.com/2014/04/07/docker-with-openvswitch.html"/>
   <updated>2014-04-07T00:00:00+08:00</updated>
   <id>http://peerxu.github.com//2014/04/07/docker-with-openvswitch</id>
   <content type="html">&lt;h1&gt;pipework -- docker网络增强工具&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/jpetazzo/pipework&quot;&gt;pipework&lt;/a&gt;是&lt;a href=&quot;https://www.docker.io/&quot;&gt;Docker&lt;/a&gt;的一个网络增强功能插件.&lt;/p&gt;

&lt;p&gt;Docker创建的时候, 默认是接入docker0(linux bridge)的. 所以只能单主机工作, 不能多台主机联动工作. 这时候, pipework应运而生.&lt;/p&gt;

&lt;p&gt;我们先来介绍一下pipework的简单用法, 之后再深入探讨关于pipework与ovs的结合. 最后基于一个案例分析来结束.&lt;/p&gt;

&lt;h3&gt;pipework入门&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;# brctl addbr br0
# ip link set dev br0 up
# ip addr add 192.168.2.1/24 dev br0
# MYSQL=$(docker run -d -p 3306:3306 -e MYSQL_PASS=admin tutum/mysql)
# pipework br0 $MYSQL 192.168.2.100/24
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;创建一个br0(linux bridge).&lt;/li&gt;
&lt;li&gt;配置IP地址给br0.&lt;/li&gt;
&lt;li&gt;启动一个mysql docker.&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;pipework&lt;/code&gt;为docker添加IP地址.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;经过这几个步骤后, 创建的docker就有一个设置指定的IP地址了.
pipework的具体工作原理就不在这里详细分析, 有兴趣的同学可以自己去读源代码.&lt;/p&gt;

&lt;h3&gt;pipework进阶&lt;/h3&gt;

&lt;p&gt;上面入门介绍中, 我们使用pipework工具, 通过linux bridge的模式指定IP地址给docker容器.
其实, 除了linux bridge, pipework还支持现在流行的虚拟交换机(Open vSwitch).
下面简单的示范一下如何将docker与Open vSwitch(下称ovs)连通.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ovs-vsctl add-br ovsbr0
# ip link set dev ovsbr0 up
# ip addr add 192.168.3.1/24 dev ovsbr0
# MYSQL=$(docker run -d -p 3306:3306 -e MYSQL_PASS=admin tutum/mysql)
# pipework ovsbr0 $MYSQL 192.168.3.100/24
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于pipework来说, 底层使用什么虚拟网络设备是透明的.
pipework会智能地判断使用的是linux bridge还是ovs.
所以除了创建桥的方式不同, 其他并没有改变.&lt;/p&gt;

&lt;h3&gt;pipework案例分析&lt;/h3&gt;

&lt;p&gt;下面就具体分析一个pipework的应用场景.&lt;/p&gt;

&lt;h4&gt;docker容器与VLAN&lt;/h4&gt;

&lt;p&gt;docker容器启动时, 默认是接入到docker0网桥上的. 这样就容易给大家造成一个假象, docker容器只能运行在单机的情况下.
&lt;em&gt;但是显示并非如此.&lt;/em&gt;
我们可以通过pipework扩展docker的网络功能.&lt;/p&gt;

&lt;p&gt;我们假设现在有2台服务器A和B, 交换机S.
现在我们同时在A,B上创建虚拟网桥ovsbr0. 并且在服务器A上, 将网桥启用和配置IP地址.
那么我们现在如果在A,B上,分别启动一个docker.
同时通过pipework将docker接入到ovsbr0上, 并且配置与A服务器上ovs相同网段的IP地址.
那么&lt;em&gt;两个docker互相之间就能够通信&lt;/em&gt;了.
很神奇有木有!!!&lt;/p&gt;

&lt;p&gt;但是万恶的需求是不断进化的(呵呵). 不会都让你们的docker运行在一个网络环境下, 有的应用是需要互相隔离的.
那么就有可能需要VLAN的划分. 这里多说点, 其实在现今的情况下, 除了划分VLAN还有其他的方式达到二层网络隔离的效果, 如VXLAN, NVGRE等技术.
但是我们现在还是只谈论VLAN隔离吧.&lt;/p&gt;

&lt;p&gt;我们先在服务器A上做一下操作:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# D1V10=$(docker run -i -t learn/ping /bin/bash)
# pipework ovsbr0 -i d1v10 $D1V10 10.1.1.10/24
# D2V10=$(docker run -i -t learn/ping /bin/bash)
# pipework ovsbr0 -i d2v10 $D2V10 10.1.1.11/24
# D3V20=$(docker run -i -t learn/ping /bin/bash)
# pipework ovsbr0 -i d3v20 $D3V20 10.1.1.20/24
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里定义了3个Docker容器, 并且将其添加到ovsbr0这个桥上.
下面开始将不同的网卡设置vlan id.
我们将 D1V10 和 D2V10 设置vlan id为10. 将D3V20 设置vlan id为20.&lt;/p&gt;

&lt;p&gt;我们可以通过&lt;code&gt;ovs-vsctl list-ports &amp;lt;BRIDGE&amp;gt;&lt;/code&gt;找出桥设备下面的所有端口.
但是刚刚我们一口气连续创建了3个docker, 会看见3个对应的虚拟网卡.&lt;/p&gt;

&lt;p&gt;然后我们需要做的是, 找出与Docker容器想对应的虚拟网卡.
刚刚在pipework执行时, 添加了参数&lt;code&gt;-i&lt;/code&gt;, 意思是创建的虚拟网卡结尾对应的字符串.&lt;/p&gt;

&lt;p&gt;比如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# pipework ovsbr0 -i d1v10 $D1V10 10.1.1.10/24
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这命令执行后, ovsbr0设备会添加一个port, port的名字应该是&lt;code&gt;plxxxxd1v10&lt;/code&gt;.
当中的xxxx是docker容器的pid.&lt;/p&gt;

&lt;p&gt;这时我们就可以通过&lt;code&gt;ovs-vsctl set port &amp;lt;port&amp;gt; tag=&amp;lt;vlan id&amp;gt;&lt;/code&gt;的方式设置vlan id了.&lt;/p&gt;

&lt;p&gt;下面是范例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ovs-vsctl list-ports ovsbr0
pl23016d1v10
pl23124d2v10
pl23654d3v20
# ovs-vsctl set port pl23016d1v10 tag=10
# ovs-vsctl set port pl23124d2v10 tag=10
# ovs-vsctl set port pl23654d3v20 tag=20
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就完成了设置VLAN的步骤了.
下面我们通过简单的ping命令来验证一下vlan隔离的效果.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker attach $D1V10
root@f94dc85c44b1:/# ping 10.1.1.11  # reachable
root@f94dc85c44b1:/# ping 10.1.1.20  # unreachable
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;多服务器的vlan划分&lt;/h4&gt;

&lt;p&gt;可能有同学以为, docker只能在单机上工作(docker与docker之间通信只能在本机进行).
但是使用pipework增强插件后, 我们可以通过Linux Bridge或Open vSwitch来进行数据交换.
这样就可以不仅仅局限于Docker默认的隔离桥(原谅我的破翻译, 我真不知道怎么形容这货 --&gt; docker0)&lt;/p&gt;

&lt;h3&gt;总结&lt;/h3&gt;

&lt;p&gt;pipework是个强大的docker网络管理工具. 具体的实现也比较简单. 可以配合ovs来实现强大的功能.
剩下就是发挥想象力的时间了...&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>让你的Docker运行在Open vSwitch上</title>
   <link href="http://tom.preston-werner.com/2013/12/24/docker-on-openvswitch.html"/>
   <updated>2013-12-24T00:00:00+08:00</updated>
   <id>http://peerxu.github.com//2013/12/24/docker-on-openvswitch</id>
   <content type="html">&lt;h1&gt;让你的Docker运行在Open vSwitch上&lt;/h1&gt;

&lt;p&gt;docker创建的container只能运行在docker创建的docker0上(linux bridge).
所以就有了&lt;a href=&quot;https://github.com/PeerXu/pipework&quot;&gt;pipework&lt;/a&gt;这个项目.&lt;/p&gt;

&lt;h2&gt;pipework范例&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;# ovs-vsctl add-br br0
# ip link set br0 up
# ip addr add 10.0.0.1/24 dev br0
# pipework br0 $(docker run -d mysql /usr/sbin/mysqld_safe) 10.0.0.200/24
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上几行脚本的意思是:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;创建一个Open vSwitch的桥br0&lt;/li&gt;
&lt;li&gt;设置br0的ip地址为10.0.0.1&lt;/li&gt;
&lt;li&gt;在br0上创建一个docker并绑定IP地址&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;pipework工作原理&lt;/h2&gt;

&lt;p&gt;创建一对&lt;a href=&quot;http://wangcong.org/blog/archives/1704&quot;&gt;veth&lt;/a&gt;, 将一头绑定到docker内, 另外一头绑定到Open vSwitch.
然后通过&lt;em&gt;iproute&lt;/em&gt; 绑定IP地址等等操作.&lt;/p&gt;

&lt;p&gt;然后, 就没有然后了.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Git Patch简单教程</title>
   <link href="http://tom.preston-werner.com/2013/11/21/patch-with-git-tutorial.html"/>
   <updated>2013-11-21T00:00:00+08:00</updated>
   <id>http://peerxu.github.com//2013/11/21/patch-with-git-tutorial</id>
   <content type="html">&lt;h1&gt;Git Patch简单教程&lt;/h1&gt;

&lt;p&gt;今天我们来学习一下关于git怎么创建与应用patch.&lt;/p&gt;

&lt;h3&gt;预备资料&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://zh.wikipedia.org/zh-cn/Patch&quot;&gt;patch&lt;/a&gt;是用来对现有的源代码进行更新的一种手段.&lt;/p&gt;

&lt;p&gt;patch可以通过diff, git, svn, hg等工具生成.&lt;/p&gt;

&lt;p&gt;diff与git产成的patch文件有点差异(下面会简单的介绍patch文档的结构).&lt;/p&gt;

&lt;p&gt;下面我们就来介绍怎么创建一个patch.&lt;/p&gt;

&lt;h3&gt;前戏&lt;/h3&gt;

&lt;p&gt;首先, 你得有一个好环(ji)境(you), 才能开展patch的工作.&lt;/p&gt;

&lt;p&gt;所以我在这里简单的创(ji)建(you)一个环境给大家使用. :P&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir Hello
$ cd hello
$ git init
$ cat &amp;lt;&amp;lt; EOF &amp;gt; hello.py
#!/usr/bin/env python2.7
print &quot;hello, world&quot;
EOF
$ git add .
$ git commit -m &quot;initial commit&quot; -a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此, 大家已经有一个可以使用的好环(ji)境(you).(怎么感觉节奏不对)&lt;/p&gt;

&lt;h3&gt;动作片播放ing...&lt;/h3&gt;

&lt;p&gt;好了, 我们已经创建好了一个可以用的基友, 那么就开始干吧!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout -b my-feature
$ vi hello.py
$ cat hello.py
#!/usr/bin/env python2.7
def hello(name):
    print &quot;hello, %s&quot; % name

hello(&quot;world&quot;)
$ git commit -m &quot;add feature&quot; -a
$ git format-patch master
$ ls
0001-add-feature.patch  hello.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面来为大家讲解一下上面的&lt;em&gt;动作&lt;/em&gt;要领.&lt;/p&gt;

&lt;p&gt;首先我们很大众的开局, 先创建一个my-feature.&lt;/p&gt;

&lt;p&gt;然后啪啪啪地编辑了一下文档, 添加了一个相当犀利的特性.&lt;/p&gt;

&lt;p&gt;然后按照正常套路去commit咱们牛逼的特性.&lt;/p&gt;

&lt;p&gt;当全世界都以为我们要merge到master的时候, 我只能说你们, 图样图森普.&lt;/p&gt;

&lt;p&gt;我们的目标是没有蛀牙. 咳咳, 是创建patch.&lt;/p&gt;

&lt;p&gt;所以我们最后使用 &lt;code&gt;git format-patch master&lt;/code&gt; 创建一个patch.&lt;/p&gt;

&lt;p&gt;好了, 通常动作片的中场都是要休息一下的.&lt;/p&gt;

&lt;h3&gt;动作片继续播放ing...&lt;/h3&gt;

&lt;p&gt;我们既然已经生成了patch文件, 咱们就看看这文件到底是什么样子的.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;From a9706e72ba4976f69d1c3ca5e93ab9a00757c9fd Mon Sep 17 00:00:00 2001
From: Peer Xu &amp;lt;pppeerxu@gmail.com&amp;gt;
Date: Thu, 21 Nov 2013 23:37:41 +0800
Subject: [PATCH] add feature

---
 hello.py | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/hello.py b/hello.py
index 6635083..c314e13 100644
--- a/hello.py
+++ b/hello.py
@@ -1,2 +1,5 @@
 #!/usr/bin/env python2.7
-print &quot;hello,world&quot;
+def hello(name):
+    print &quot;hello, %s&quot; % name
+
+hello(&quot;world&quot;)
--
1.8.3.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以我阅片无数的经验, 这是一封邮件.&lt;/p&gt;

&lt;p&gt;嗯, 剩下的就留给各位看官自己去YY吧.&lt;/p&gt;

&lt;h3&gt;动作片通常都是分开三部播放的...&lt;/h3&gt;

&lt;p&gt;这里, 我传授大家怎么将git生成的patch应用到项目中去.&lt;/p&gt;

&lt;p&gt;还是咱们的好环境.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cp 0001-add-feature.patch /dev/shm/
$ rm 0001-add-feature.patch # 删除生成的patch, 保证环境干净 (这是你洁癖的证据!)
$ git checkout master
$ git am /dev/shm/0001-add-feature.patch
$ cat hello.py
#!/usr/bin/env python2.7
def hello(name):
    print &quot;hello, %s&quot; % name

hello(&quot;world&quot;)
$ git log # 这里可以看到应用patch的日志
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们先将patch复制到另外一个地方(假装是从很远的地方下载下来的)&lt;/p&gt;

&lt;p&gt;然后checkout到master(假装在别的环境中...)&lt;/p&gt;

&lt;p&gt;然后使用 &lt;code&gt;git am&lt;/code&gt; 这命令使patch应用到环境中去.&lt;/p&gt;

&lt;p&gt;然后, 就没有然后了...&lt;/p&gt;

&lt;h3&gt;动作片再好, 也不能经常看...&lt;/h3&gt;
</content>
 </entry>
 
 <entry>
   <title>kombu 入门教程(上)</title>
   <link href="http://tom.preston-werner.com/2013/10/05/kombu-tutorial_I.html"/>
   <updated>2013-10-05T00:00:00+08:00</updated>
   <id>http://peerxu.github.com//2013/10/05/kombu-tutorial_I</id>
   <content type="html">&lt;h1&gt;kombu 入门教程(上)&lt;/h1&gt;

&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;本文是&lt;a href=&quot;https://github.com/celery/kombu&quot;&gt;kombu框架&lt;/a&gt;(一个基于python的消息队列框架)的入门教程. 文章会简单介绍消息队列中的基本概念和kombu框架的简单使用方法.&lt;/p&gt;

&lt;h2&gt;Hello World&lt;/h2&gt;

&lt;p&gt;我们来了解一下, 一个简单的消息队列里面, 应该包含以下的对象.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Producer&lt;/strong&gt; -- 负责消息的发送&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Consumer&lt;/strong&gt; -- 负责消息的接收&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Queue&lt;/strong&gt; -- 负责消息的传输&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Exchange&lt;/strong&gt; -- 负责消息的分发&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;在我们的&lt;strong&gt;Hello World&lt;/strong&gt;中, 我们只看到了创建&lt;strong&gt;Queue&lt;/strong&gt;的过程, 其实一个完整消息队列应用程序是会包含上面所说的所有实体的.&lt;/p&gt;

&lt;p&gt;但是kombu很贴心的为我们封装了一个便于使用的&lt;strong&gt;SimpleQueue&lt;/strong&gt;类, 让我们能够快速地开发.&lt;/p&gt;

&lt;p&gt;下面我们就围绕着这个&lt;strong&gt;SimpleQueue&lt;/strong&gt;类来进行简单的试验:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import kombu
conn = kombu.Connection('redis://localhost')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;导入kombu模块, 并且创建一个连接, 连接到本地的Redis服务上(本文的介绍都是基于Redis作为消息队列后端)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def message_process(body, message):
    print &quot;[x] %s&quot; body
    message.ack()
queue = conn.SimpleQueue('demo')
queue.consumer.callbacks = [message_process]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里定义了一个&lt;strong&gt;message_process&lt;/strong&gt;函数, 用于处理消息.
需要注意的是, 当消息处理完之后, 要发送调用message对象的ack方法来确保消息已经被正确处理.
如果没有确认的话, 那么消息依然放置在队列当中, 当作没有被处理.&lt;/p&gt;

&lt;p&gt;之后创建了一个消息队列, 命名为&lt;strong&gt;demo&lt;/strong&gt;. 并且给队列的consumer绑定了一个消息处理函数.&lt;/p&gt;

&lt;p&gt;以上就是关于消息接收的一些过程, 下面继续介绍一下消息发送的过程.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;queue.put('hello,world')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建消息队列的过程与消息接收的相同, 要注意的就是不需要为消息队列指定consumer的处理函数.
直接调用queue的put方法就可以发送消息了.&lt;/p&gt;

&lt;p&gt;完整的代码如下:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;receiver.py&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import kombu

def message_process(body, message):
    print &quot;[x] %s&quot; % body
    message.ack()

conn = kombu.Connection('redis://localhost')
queue = conn.SimpleQueue('demo')
queue.consumer.callbacks = [message_process]

queue.get()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;sender.py&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import kombu

conn = kombu.Connection('redis://localhost')
queue = conn.SimpleQueue('demo')
queue.put('hello, world')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动receiver:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python receiver.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发送消息:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python sender.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后会在receiver的终端上看见:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python receiver.py
[x] hello world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单的消息队列应用就这样.&lt;/p&gt;

&lt;p&gt;感谢阅读~&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>机器学习笔记 -- k-临近算法</title>
   <link href="http://tom.preston-werner.com/2013/08/18/machine-learning-knn-with-clojure.html"/>
   <updated>2013-08-18T00:00:00+08:00</updated>
   <id>http://peerxu.github.com//2013/08/18/machine-learning-knn-with-clojure</id>
   <content type="html">&lt;h1&gt;机器学习笔记 -- k-临近算法&lt;/h1&gt;

&lt;p&gt;k-临近算法是一种分类算法, 计算输入值与各个特征值之间距离来进行分类.&lt;/p&gt;

&lt;p&gt;简单的概括一下算法的思路就是:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;算出输入值与各个特征值之间的距离, 按升序排序.&lt;/li&gt;
&lt;li&gt;获取前k个分类&lt;/li&gt;
&lt;li&gt;选择出现次数最高的分类, 就是输入值所属的分类.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;k-临近算法优缺点分析&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;优点: 精度高, 对异常值不敏感, 无数据输入假定.&lt;/li&gt;
&lt;li&gt;缺点: 计算复杂度高, 空间复杂度高.&lt;/li&gt;
&lt;li&gt;适用数据范围: &lt;strong&gt;数值型&lt;/strong&gt; 和 &lt;strong&gt;标称型&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;以下通过clojure来实现kNN算法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defn create-test-data []  ; 生成测试数据
  '(((0.1 0.1)
     (0.0 0.0)
     (0.2 0.2)
     (1.1 1.1)
     (1.0 1.0))
    (:a :a :a :b :b)))

(defn distance [xs ys]  ; 计算两个向量之间的距离
  (. java.lang.Math sqrt (apply + (map #(* % %) (map #(- %1 %2) xs ys)))))

(defn count-list-element [xs]  ; 计算列表中每个元素的出现次数
  (reduce
   (fn [cnts x]
    (let [n (x cnts)]
     (if (= n nil)
      (assoc cnts x 1)
      (assoc cnts x (+ n 1)))))
   {}
   xs))

(defn kNN [inX dataSet labels k]
 (let* [label-groups (map #(concat [%1] %2) labels dataSet)  ; 将分类与特征值合并, 方便后续处理
        label-groups-sort-by-distance (sort-by  ; 计算输入值与特征值的距离并且排序
                                       #(distance inX (rest %1)) label-groups)
        k-labels (take k (map first label-groups-sort-by-distance))  ; 获取前K个分类
        labels-group-by-count (sort-by first (count-list-element k-labels))]  ; 计算每个分类的出现次数
       (-&amp;gt; labels-group-by-count  ; 返回出现次数最多的分类
           reverse
           first
           first)))

(defn -main [&amp;amp; args]
  (let [[groups labels] (create-dataset)]
    (println (kNN [0.0 0.0] groups labels 3))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;附带上我的&lt;a href=&quot;https://github.com/PeerXu/machine-learning-clojure&quot;&gt;机器学习笔记&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;感谢阅读&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>InetAddress类中isReachable方法检测原理</title>
   <link href="http://tom.preston-werner.com/2013/04/03/check-host-is-reachable-by-clojure.html"/>
   <updated>2013-04-03T00:00:00+08:00</updated>
   <id>http://peerxu.github.com//2013/04/03/check-host-is-reachable-by-clojure</id>
   <content type="html">&lt;h1&gt;InetAddress类中isReachable方法检测原理&lt;/h1&gt;

&lt;p&gt;今日, 有一同事问我, 为什么我用ping命令可以连通的一台主机, 用java的InetAddress类中的isReachable方法就测试失败呢?&lt;/p&gt;

&lt;p&gt;当时我就感觉奇怪了, 难道isReachable用的不是ping?&lt;/p&gt;

&lt;p&gt;刚刚测试了一下, 果然真不是用ping... 用的是 &lt;a href=&quot;http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers&quot; title=&quot;echo&quot;&gt;echo&lt;/a&gt;协议.&lt;/p&gt;

&lt;p&gt;那么不可达的原因就不言而喻了, 因为目的主机没有启动echo服务.&lt;/p&gt;

&lt;p&gt;附上clojure的测试代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(.. java.net.InetAddress (getByName &quot;192.168.1.1&quot;) (isReachable 1000))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;吐槽: 如果是java的话要多长才能完成这个简单的测试呢?&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>利用cscope阅读python代码</title>
   <link href="http://tom.preston-werner.com/2013/02/14/read-python-code-with-cscope-on-emacs.html"/>
   <updated>2013-02-14T00:00:00+08:00</updated>
   <id>http://peerxu.github.com//2013/02/14/read-python-code-with-cscope-on-emacs</id>
   <content type="html">&lt;h1&gt;利用cscope阅读python代码&lt;/h1&gt;

&lt;p&gt;本文是教你怎么使用 cscope+emacs来阅读 python代码, 网上已经有很多使用 cscope+emacs阅读 c/c++代码的教程. 但是没有找到python的, 故有了本文.&lt;/p&gt;

&lt;p&gt;最近在阅读 quantum的代码, 必须有一个能够使用的代码阅读器. 正所谓工欲善其事,必先利其器.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Cscope&quot; title=&quot;cscope wiki&quot;&gt;cscope&lt;/a&gt;是一个代码索引数据库.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://linux.die.net/man/1/xcscope&quot; title=&quot;xcscope 介绍&quot;&gt;xcscope&lt;/a&gt;是 cscope在 emacs上面的一个插件, 提供构建 cscope数据库到代码跳转一条龙服务.&lt;/p&gt;

&lt;p&gt;安装 cscope&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install cscope
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改 xcscope.el, 以提供 python-mode支持(我的xcscope.el在/usr/share/emacs/site-lisp/下)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
(add-hook 'c-mode-hook (function cscope:hook))
(add-hook 'c++-mode-hook (function cscope:hook))
(add-hook 'dired-mode-hook (function cscope:hook))
*(add-hook 'python-mode-hook (function cscope:hook))* ; 添加 xcscope的 python-mode 支持
(provide 'xcscope)
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启用 xcscope&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat ~/.emacs
...
;;; xcscope plugin
(load-file &quot;/usr/share/emacs/site-lisp/xcscope.el&quot;)
(require 'xcscope)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成 cscope数据库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd ~/opt/openstack/quantum/ # quantum路径
$ find . -name &quot;*.py&quot; | cscope -Rbq -i - # 生成 python文件的 cscope数据库
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开 emacs, enjoy it.&lt;/p&gt;

&lt;p&gt;下面是一些常用的 cscope快捷键&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C-c s s         Find symbol.
C-c s d         Find global definition.
C-c s g         Find global definition (alternate binding).
C-c s G         Find global definition without prompting.
C-c s c         Find functions calling a function.
C-c s C         Find called functions (list functions called from a function).
C-c s t         Find text string.
C-c s e         Find egrep pattern.
C-c s f         Find a file.
C-c s i         Find files #including a file.

C-c s b         Display *cscope* buffer.
C-c s B         Auto display *cscope* buffer toggle.
C-c s n         Next symbol.
C-c s N         Next file.
C-c s p         Previous symbol.
C-c s P         Previous file.
C-c s u         Pop mark.
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>git备忘录</title>
   <link href="http://tom.preston-werner.com/2013/01/28/git-notes.html"/>
   <updated>2013-01-28T00:00:00+08:00</updated>
   <id>http://peerxu.github.com//2013/01/28/git-notes</id>
   <content type="html">&lt;h1&gt;git备忘录&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;删除远程分支&lt;/em&gt; &lt;/br&gt;
 &lt;code&gt;git push &amp;lt;remote&amp;gt; :&amp;lt;branch&amp;gt;&lt;/code&gt; &lt;/br&gt;
 example: 删除origin仓库上的backup分支 &lt;code&gt;git push origin :backup&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;通过指定ssh端口号添加远程仓库&lt;/em&gt; &lt;/br&gt;
 &lt;code&gt;git remote add ssh://&amp;lt;username&amp;gt;@&amp;lt;hostname&amp;gt;:&amp;lt;port&amp;gt;/&amp;lt;project_path&amp;gt;&lt;/code&gt; &lt;/br&gt;
 example: 添加用户名为pi, 端口为15002, 主机名为raspi.me, 项目路径为 /home/pi/project.git &lt;/br&gt;
 &lt;code&gt;git remote add ssh://pi@raspi.me:15002/home/pi/project.git&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>OpenvSwitch gre隧道配置</title>
   <link href="http://tom.preston-werner.com/2013/01/15/open-vswitch-gre-tunnel-configuration.html"/>
   <updated>2013-01-15T00:00:00+08:00</updated>
   <id>http://peerxu.github.com//2013/01/15/open-vswitch-gre-tunnel-configuration</id>
   <content type="html">&lt;h1&gt;OpenvSwitch gre隧道配置&lt;/h1&gt;

&lt;p&gt;本文是讲述如何在OpenvSwitch交换机上配置gre隧道的. 不废话, 马上开始吧.&lt;/p&gt;

&lt;p&gt;本文要求读者对Openvswitch, Mininet, Openflow, Pox有一定了解.&lt;/p&gt;

&lt;p&gt;实验环境如下:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Host * 2

&lt;ul&gt;
&lt;li&gt;主机上安装了OpenvSwitch与mininet&lt;/li&gt;
&lt;li&gt;分别命名2台主机为H0和H1(程序员都是从0开始计数的)&lt;/li&gt;
&lt;li&gt;H0: ip地址: 192.168.122.150 eth0绑定到br1上 (绑定过程参考实验过程)&lt;/li&gt;
&lt;li&gt;H1: ip地址: 192.168.122.151 eth0绑定到br1上&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Openflow 控制器主机 (可以是上面其中一台)

&lt;ul&gt;
&lt;li&gt;命名为C0&lt;/li&gt;
&lt;li&gt;选用pox控制器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;实验目的: 通过构建gre隧道, 让2个隔离的datapath(fake bridge)虚拟机通信&lt;/p&gt;

&lt;p&gt;实验简介:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在C0上启动pox控制器&lt;/li&gt;
&lt;li&gt;在H0上创建br1, 将eth0绑定到br1上, 完成相关配置.&lt;/li&gt;
&lt;li&gt;在H0上以对应参数启动mininet, 并且配置dp0, 与设置mininet的虚拟机h2, h3.&lt;/li&gt;
&lt;li&gt;为H0上创建gre通道&lt;/li&gt;
&lt;li&gt;H1同理&lt;/li&gt;
&lt;li&gt;在H0的miminet控制台中, 使用h2 pingH1上的h2.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;实验过程:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 启动pox控制器
C0 $ ./pox.py forwarding.l2_learning

# 配置H0
# 配置br1
H0 # ovs-vsctl add-br br1
H0 # ovs-vsctl add-port br1 eth0
H0 # ip addr add 192.168.122.150/24 dev br1
H0 # ip route add default via 192.168.122.1 dev br1
# 启动mininet, 选择远程控制器, 连接到192.168.122.1的控制器上.
H0 # mn --switch=ovsk --controller=remote --ip=192.168.122.1
# 添加gre隧道, 连接到192.168.122.151
H0 # ovs-vsctl add-port dp0 gre0 -- set interface gre0 type=gre options:remote_ip=192.168.122.151

# 配置H1
# 配置br1
H1 # ovs-vsctl add-br br1
H1 # ovs-vsctl add-port br1 eth0
H1 # ip addr add 192.168.122.151/24 dev br1
H # ip route add default via 192.168.122.1 dev br1
# 启动mininet, 选择远程控制器, 连接到192.168.122.1的控制器上.
H1 # mn --switch=ovsk --controller=remote --ip=192.168.122.1
# 添加gre隧道, 连接到192.168.122.150
H1 # ovs-vsctl add-port dp0 gre0 -- set interface gre0 type=gre options:remote_ip=192.168.122.150
# H1的mininet控制台
mininet&amp;gt; h2 ip addr replace 10.0.0.4/24 dev h2-eth0
mininet&amp;gt; h3 ip addr replace 10.0.0.5/24 dev h3-eth0

# H0的mininet控制台
mininet&amp;gt; h2 ping -c 2 10.0.0.4
PING 10.0.0.4 (10.0.0.4) 56(84) bytes of data.
64 bytes from 10.0.0.4: icmp_req=1 ttl=64 time=54.5 ms
64 bytes from 10.0.0.4: icmp_req=2 ttl=64 time=0.499 ms
--- 10.0.0.4 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1002ms
rtt min/avg/max/mdev = 0.499/27.526/54.554/27.028 ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考文章: &lt;a href=&quot;http://networkstatic.net/open-vswitch-gre-tunnel-configuration/&quot;&gt;http://networkstatic.net/open-vswitch-gre-tunnel-configuration/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;enjoy it.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>用树莓派与github构建自己的DDNS服务(上)</title>
   <link href="http://tom.preston-werner.com/2013/01/13/using-rpi-and-github-to-build-your-ddns-server-part-1.html"/>
   <updated>2013-01-13T00:00:00+08:00</updated>
   <id>http://peerxu.github.com//2013/01/13/using-rpi-and-github-to-build-your-ddns-server-part-1</id>
   <content type="html">&lt;h1&gt;用树莓派与github构建自己的DDNS服务(上)&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E5%8B%95%E6%85%8BDNS&quot;&gt;DDNS&lt;/a&gt;&lt;/em&gt; -- 动态域名解析服务, 是一种把互联网域名指向可变IP地址的系统.
这次我们的域名提供商选择了&lt;a href=&quot;https://www.github.com/&quot; title=&quot;github&quot;&gt;github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;github上提供了一个静态页面服务&lt;a href=&quot;http://pages.github.com/&quot; title=&quot;github pages&quot;&gt;gh-pages&lt;/a&gt;, 我们就是利用这个服务来达到DDNS的目的的.&lt;/p&gt;

&lt;p&gt;你需要一下几样东西:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Raspberry Pi&lt;/li&gt;
&lt;li&gt;有基础的&lt;a href=&quot;http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn/&quot; title=&quot;git教程&quot;&gt;git&lt;/a&gt;使用经验&lt;/li&gt;
&lt;li&gt;github 帐号&lt;/li&gt;
&lt;li&gt;在Raspbeery Pi上设定github的SSH keys, 并提交代码时不需要输入密码. &lt;strong&gt;如果你的SSH key有密码的话,可以使用&lt;a href=&quot;http://clonn.blogspot.com/2012/03/ssh-agent.html&quot; title=&quot;ssh-agent教程 需翻墙&quot;&gt;ssh-agent&lt;/a&gt;配置免密码提交&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;开始我们的旅程吧!&lt;/p&gt;

&lt;h3&gt;server端配置&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;登录github, fork &lt;a href=&quot;https://www.github.com/peerxu/slipper&quot;&gt;slipper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;clone该项目到 &lt;code&gt;~/.slipper&lt;/code&gt; 目录, &lt;code&gt;git clone git@github.com/&amp;lt;你的github帐号&amp;gt;/slipper.git ~/.slipper&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;进入到 &lt;code&gt;.slipper&lt;/code&gt; 目录. &lt;code&gt;cd ~/.slipper&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;创建一个名为&lt;em&gt;gh-pages&lt;/em&gt;的分支, &lt;code&gt;git checkout -b gh-pages&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;复制&lt;code&gt;server/update.sh&lt;/code&gt;到当前目录&lt;code&gt;~/.slipper&lt;/code&gt;. &lt;code&gt;cp server/update.sh .&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;进入&lt;a href=&quot;http://linux.vbird.org/linux_basic/0430cron.php&quot; title=&quot;cron&quot;&gt;cron&lt;/a&gt;定时任务配置, &lt;code&gt;crontab -e&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将update.sh脚本配置到定时执行中 &lt;code&gt;*/5 * * * * ~/.slipper/update.sh&lt;/code&gt;, 保存退出&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;server端配置已经完毕, 过几分钟, 你用curl获取你的Rpi运行IP &lt;code&gt;curl http://&amp;lt;你的github帐号&amp;gt;.github.com/slipper/addr&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;下一篇将会为大家介绍client端的设置和应用场景. 如自建博客域名解析, ssh反向连接等.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>在树莓派的archlinux中安装lxde</title>
   <link href="http://tom.preston-werner.com/2013/01/03/rpi-install-lxde-on-archlinux.html"/>
   <updated>2013-01-03T00:00:00+08:00</updated>
   <id>http://peerxu.github.com//2013/01/03/rpi-install-lxde-on-archlinux</id>
   <content type="html">&lt;h2&gt;在树莓派的archlinux中安装lxde&lt;/h2&gt;
&lt;p&gt;archlinux是一个很好的linux发行版, 比raspbian好多了. 况且archlinux的yaourt工具实在是太强大了.&lt;/p&gt;
&lt;p&gt;好了,废话不多说了, 直接上代码:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# pacman -Syu
# pacman -S xf86-video-fbdev lxde xorg-xinit dbus
# cat &amp;lt;&amp;lt; EOF &amp;gt; ~/.xinitrc
exec startlxde
EOF
# startx&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;经过漫长的等待之后就可以启动这个 &lt;em&gt;丑陋的&lt;/em&gt; 桌面了.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>SSH反向链接配置</title>
   <link href="http://tom.preston-werner.com/2012/11/27/remote-server-host-for-ssh.html"/>
   <updated>2012-11-27T00:00:00+08:00</updated>
   <id>http://peerxu.github.com//2012/11/27/remote-server-host-for-ssh</id>
   <content type="html">&lt;h2&gt;SSH反向链接配置&lt;/h2&gt;
&lt;p&gt;应用场景:&lt;br /&gt;
A为公网上的一个SSH服务器, 端口为9944, ip为9.9.9.9, 用户名为a, 本地开放端口为10000,&lt;br /&gt;
B为内网里的一个SSH服务器, 端口为22, 用户为b.&lt;br /&gt;
如今A向B发起SSH请求,实行远程操控.&lt;/p&gt;
&lt;p&gt;A的SSH服务端口为9944.&lt;br /&gt;
B的SSH服务端口为22.&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;先在B上执行: &lt;code&gt;B $ ssh -R 10000:localhost:22 a@9.9.9.9 -p 9944&lt;/code&gt;&lt;/li&gt;
	&lt;li&gt;之后就可以在A上执行: &lt;code&gt;A $ ssh b@localhost -p 10000&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;enjoy it.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>clojure-py gevent wsgi hello world</title>
   <link href="http://tom.preston-werner.com/2012/10/11/clojure-py-gevent-wsgi-hello-world.html"/>
   <updated>2012-10-11T00:00:00+08:00</updated>
   <id>http://peerxu.github.com//2012/10/11/clojure-py-gevent-wsgi-hello-world</id>
   <content type="html">&lt;h2&gt;clojure-py gevent wsgi hello world&lt;/h2&gt;
&lt;p&gt;clojure-py项目是clojure语言在pure python上的实现. 可以在github上找到该项目或者直接用easy_install安装.&lt;/p&gt;
&lt;p&gt;server.clj&lt;/p&gt;
&lt;pre&gt;
(require 'gevent.wsgi)

(defn hello-handler [env res]
    (res &quot;200 OK&quot; (list '(&quot;Content-Type&quot; &quot;text/html&quot;)))
    [&quot;hello, world&quot;])

(def httpd (gevent.wsgi/WSGIServer (py/tuple '(&quot;localhost&quot; 8080))
                                   hello-handler))

(println &quot;listen on localhost:8080&quot;)
(.serve_forever httpd)
&lt;/pre&gt;
&lt;p&gt;保存好之后, 执行: &lt;code&gt;clojurepy server.clj&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;enjoy it.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>在ubuntu12.04中编译newlisp</title>
   <link href="http://tom.preston-werner.com/2012/08/30/compile-newlisp-on-ubuntu-12.04.html"/>
   <updated>2012-08-30T00:00:00+08:00</updated>
   <id>http://peerxu.github.com//2012/08/30/compile-newlisp-on-ubuntu-12.04</id>
   <content type="html">&lt;h2&gt;在ubuntu12.04中编译newlisp&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ wget http://www.newlisp.org/downloads/newlisp-10.4.3.tgz
$ tar zxvf newlisp-10.4.3.tgz
$ cd newlisp-10.4.3
$ make&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;提示 fatal error: readline/readline.h: No such file or directory&lt;br /&gt;
通过apt-file工具查找到对应的依赖包 libreadline6-dev&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ apt-file search readline/readline.h
guile-1.6-dev: /usr/include/guile-readline/readline.h
libreadline-gplv2-dev: /usr/include/readline/readline.h
libreadline6-dev: /usr/include/readline/readline.h&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以首先安装 libreadline6-dev&lt;/p&gt;
&lt;pre&gt;$ sudo apt-get install libreadline6-dev
$ make
$ sudo make install
$ newlisp
newLISP v.10.4.3 64-bit on Linux IPv4/6 UTF-8 libffi, execute 'newlisp -h' for more info.

&amp;gt; &quot;hello, newlisp&quot;
&quot;hello, newlisp&quot;
&lt;/pre&gt;
&lt;p&gt;enjoy it!&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>sqlite中的连接操作符</title>
   <link href="http://tom.preston-werner.com/2012/08/28/sqlite-on-left-join.html"/>
   <updated>2012-08-28T00:00:00+08:00</updated>
   <id>http://peerxu.github.com//2012/08/28/sqlite-on-left-join</id>
   <content type="html">&lt;h2&gt;sqlite中的连接操作符&lt;/h2&gt;
&lt;p&gt;sqlite中, 要使用join连接符的话, 后面的where要改成on! 例如:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from t1 left join t2 where t1.id == t2.id;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的是一个错误的例子, 应该写成如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from t1 left join t2 on t1.id == t2.id;
&lt;/code&gt;&lt;/pre&gt;</content>
 </entry>
 
 <entry>
   <title>Zombie进程的几种解决方法</title>
   <link href="http://tom.preston-werner.com/2012/08/17/zombie-process-solution.html"/>
   <updated>2012-08-17T00:00:00+08:00</updated>
   <id>http://peerxu.github.com//2012/08/17/zombie-process-solution</id>
   <content type="html">&lt;h2&gt;Zombie进程的几种解决方法&lt;/h2&gt;
&lt;p&gt;在unix和类unix系统中, 僵尸进程是指已经完成工作但是依然存有进程实例存在于进程表中的进程. 这个实例仍然需要父进程去读取它的退出状态(exit status). 通常来说, 僵尸进程并不像普通进程那样, 能够被kill命令所杀死.  &lt;del&gt;-&lt;/del&gt; 渣翻译, 出自 &lt;a herf='http://en.wikipedia.org/wiki/Zombie_process'&gt;http://en.wikipedia.org/wiki/Zombie_process&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;既然我们要处理僵尸进程, 那么我们就首先写一个僵尸进程的程序:&lt;/p&gt;
&lt;pre&gt;#!/usr/bin/env python

import os
import time

if __name__ == '__main__':
   while True:
      pid = os.fork()
      if pid == 0:
      	 // do smth.
      	 exit(0)
      time.sleep(1)&lt;/pre&gt;
&lt;p&gt;通过上面的程序, 可以稳定地, 每秒产生1个僵尸进程.(别担心, 它们不会咬人)&lt;/p&gt;
&lt;p&gt;上面的程序中, 在fork了之后, 子进程退出, 而父进程依然他的工作. 但是父进程并没有对子进程的退出状态作处理, 最后导致的是子进程无法退出.&lt;/p&gt;
&lt;p&gt;下面来讲解一下几个解决方案:&lt;/p&gt;
&lt;h3&gt;1. 父进程中调用wait等待子进程退出.&lt;/h3&gt;
&lt;pre&gt;#!/usr/bin/env python

import os
import time

if __name__ == '__main__':
   while True:
      pid = os.fork()
      if pid == 0:
      	 // do smth.
      	 exit(0)
      os.wait()
      // os.waitpid(pid, 0)
      time.sleep(1)&lt;/pre&gt;
&lt;p&gt;这种方法虽然是可行的,但是他会阻塞了父进程的工作.&lt;/p&gt;
&lt;h3&gt;2.&lt;/h3&gt;
&lt;pre&gt;#!/usr/bin/env python

import os
import time
import signal

if __name__ == '__main__':
   signal.signal(signal.SIGCHLD, signal.SIG_IGN)
   while True:
      pid = os.fork()
      if pid == 0:
      	 // do smth.
      	 exit(0)
      time.sleep(1)&lt;/pre&gt;
&lt;p&gt;在父进程忽略了子进程发出的SIGCHLD信号.&lt;br /&gt;
或者也可以自己定义一个信号处理的函数&lt;/p&gt;
&lt;h3&gt;3.&lt;/h3&gt;
&lt;pre&gt;#!/usr/bin/env python

import os
import time
import signal

if __name__ == '__main__':
   while True:
      pid = os.fork()
      if pid != 0:
      	 // do smth.
      	 exit(0)
      time.sleep(1)&lt;/pre&gt;
&lt;p&gt;这种方法是我自创的. =m=&lt;br /&gt;
既然子进程要做完事要通知父进程,这么麻烦,那么我就干脆让父进程做事.子进程负责fork算了.&lt;/p&gt;
&lt;p&gt;好吧, 讲完了.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Clojure笔记 -- namespace操作</title>
   <link href="http://tom.preston-werner.com/2012/08/12/study-clojure-namespace.html"/>
   <updated>2012-08-12T00:00:00+08:00</updated>
   <id>http://peerxu.github.com//2012/08/12/study-clojure-namespace</id>
   <content type="html">&lt;pre&gt;&lt;code&gt;(create-ns 'my.ns) ;;; 创建一个命名空间&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(require 'clojure.string) ;;; 导入命名空间&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(refer 'clojure.string) ;;; 将命名空间中所有的共有的符号导入到当前命名空间中&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(use 'clojure.string) ;;; &amp;lt;==&amp;gt; (require 'clojure.string) (refer 'clojure.string)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(remove-ns 'my.ns) ;;; 移除命名空间&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(intern 'my.ns 'foo 2) ;;; 在my.ns中绑定一个符号foo&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(alias 'str 'clojure.string) ;;; 为clojure.string起个别名 (str/split ...) &amp;lt;==&amp;gt; (clojure.string/split ...)&lt;/code&gt;&lt;/pre&gt;</content>
 </entry>
 
 <entry>
   <title>在ubuntu12.04上传goagent server端到GAE</title>
   <link href="http://tom.preston-werner.com/2012/08/11/upload-goagent-on-ubuntu12.04.html"/>
   <updated>2012-08-11T00:00:00+08:00</updated>
   <id>http://peerxu.github.com//2012/08/11/upload-goagent-on-ubuntu12.04</id>
   <content type="html">&lt;h2&gt;在ubuntu12.04上传goagent server端到GAE&lt;/h2&gt;
&lt;p&gt;到 &lt;a href='https://developers.google.com/appengine/downloads'&gt;这里&lt;/a&gt;下载 google_appengine_*.zip.&lt;/p&gt;
&lt;p&gt;我下载的版本是 google_appengine_1.7.0.zip&lt;/p&gt;
&lt;p&gt;下载完解压到 goagent 根目录下.&lt;/p&gt;
&lt;p&gt;执行下面的命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python google_appengine/appcfg.py update server/python&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;enjoy!&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>在emacs上使用中文输入法fcitx</title>
   <link href="http://tom.preston-werner.com/2012/07/21/emacs-with-fcitx-on-linux.html"/>
   <updated>2012-07-21T00:00:00+08:00</updated>
   <id>http://peerxu.github.com//2012/07/21/emacs-with-fcitx-on-linux</id>
   <content type="html">&lt;h2&gt;在emacs上使用中文输入法fcitx&lt;/h2&gt;
&lt;p&gt;在ubuntu 12.04中, 无法在emacs调用fcitx输入法. 所以给出一下解决方案.&lt;/p&gt;
&lt;p&gt;1. 在 ~/.emacs 文件中添加一下代码, 屏蔽C-SPC快捷键, 其替代快捷键为: C-@&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(global-set-key (kbd &quot;C-SPC&quot;) nil)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2. 在 ~/.bashrc 文件中添加一行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;alias emacs=&quot;LC_CTYPE='zh_CN.UTF-8' emacs&quot;&lt;/code&gt;&lt;/pre&gt;</content>
 </entry>
 
 <entry>
   <title>通过openvswitch划分vlan</title>
   <link href="http://tom.preston-werner.com/2012/07/17/create-vlan-on-openvswitch-with-libvirt.html"/>
   <updated>2012-07-17T00:00:00+08:00</updated>
   <id>http://peerxu.github.com//2012/07/17/create-vlan-on-openvswitch-with-libvirt</id>
   <content type="html">&lt;h2&gt;通过openvswitch划分vlan&lt;/h2&gt;
&lt;p&gt;目的: 在ubuntu12.04上通过openvswitch为vm划分vlan. 其中vm的管理是通过libvirt实现.&lt;/p&gt;
&lt;p&gt;首先说明一下为什么要选择libvirt的版本是0.9.13, 因为ubuntu 12.04的源中, 支持的libvirt版本是0.9.8, 但是支持openvswitch的libvirt版本是从0.9.11开始. 所以最后我选择的libvirt版本是目前最新的libvirt 0.9.13.&lt;/p&gt;
&lt;p&gt;教程会分为一下几步:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;编译, 安装libvirt 0.9.13&lt;/li&gt;
	&lt;li&gt;编译, 安装openvswitch 1.6.1&lt;/li&gt;
	&lt;li&gt;启动openvswitch&lt;/li&gt;
	&lt;li&gt;创建openvswitch网桥, 划分子网&lt;/li&gt;
	&lt;li&gt;启动vm到指定网桥&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;1. 编译, 安装libvirt 0.9.13&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ ./autogen.sh --system
$ make
$ sudo make install&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意1&lt;/strong&gt;: 在执行 &lt;code&gt;autogen.sh&lt;/code&gt; 脚本是时候, 添加上的 &lt;code&gt;--system&lt;/code&gt; , 是为了让编译时候指定到对应的系统文件夹.&lt;br /&gt;
可以发现其实是执行了一下的命令 &lt;code&gt;./configure with --prefix=/usr --sysconfdir=/etc --localstatedir=/var --libdir=/usr/lib&lt;/code&gt; , 上面的参数是有用的. 各位请记下来.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意2&lt;/strong&gt;: 在执行autogen.sh的时候, 会提示缺少什么包, 有些名字是比较诡异的. google + apt-get.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意3&lt;/strong&gt;: 由于libvirt是编译安装的, 所以在系统启动的时候不会自启动. 请手动启动libvirtd进程(root权限).&lt;/p&gt;
&lt;h3&gt;2. 编译,安装openvswitch 1.6.1&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install linux-headers-`uname -r`
$ ./configure --prefix=/usr --sysconfdir=/etc --localstatedir=/var --libdir=/usr/lib --with-linux=/lib/modules/`unam -r`/build
$ make
$ sudo make install&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意1&lt;/strong&gt;: 在linux kernel 3.3或以上, 在执行configure时, 不需要加入 &amp;#8212;with-linux 参数.&lt;/p&gt;
&lt;h3&gt;3. 启动openvswitch&lt;/h3&gt;
&lt;p&gt;在linux kernel 3.3版本以前, 需要先将bridge模块卸载, 再载入刚刚编译的openvswitch模块.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lsmod | grep bridge &amp;gt; /dev/null &amp;amp;&amp;amp; sudo rmmod bridge
insmod datapath/linux/openvswitch_mod.ko
insmod datapath/linux/brcompat_mod.ko&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在初次启动openvswitch需要初始化一下数据库:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo mkdir -p /usr/local/etc/openvswitch
$ ovsdb-tool create /usr/local/etc/openvswitch/conf.db vswitchd/vswitch.ovsschema&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后就是启动openvswitch的服务进程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo ovsdb-server --remote=punix:/usr/local/var/run/openvswitch/db.sock --remote=db:Open_vSwitch,manager_options --pidfile --detach
$ sudo ovs-vsctl --no-wait init
$ sudo ovs-vswitchd --pidfile --detach
$ sudo ovs-brcompated --pidfile --detach&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到此, 服务应该启动完毕. 我们可以用 &lt;code&gt;ovs-vsctl show&lt;/code&gt; 来验证一下是否启动成功了.&lt;/p&gt;
&lt;h3&gt;4. 创建openvswitch网桥,划分子网&lt;/h3&gt;
&lt;p&gt;先划分好网络: 存在PC1, PC2. 在PC1上启动VMa, VMb, 在PC2上启动 VMc, VMd.&lt;br /&gt;
VMa, VMc 划分到VLAN 1. VMb, VMd划分到VLAN 2.&lt;/p&gt;
&lt;p&gt;在PC1上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo brctl addbr br0
$ sudo brctl addif br0 eth0
$ sudo ifconfig eth0 0.0.0.0
$ sudo ifconfig br0 192.168.1.100/24 up&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在PC2上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo brctl addbr br0
$ sudo brctl addif br0 eth0
$ sudo ifconfig eth0 0.0.0.0
$ sudo ifconfig br0 192.168.1.101/24 up&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;5. 启动vm到指定网桥&lt;/h3&gt;
&lt;p&gt;将启动VM的xml文件中的网络配置改为使用bridge, 指向br0.&lt;br /&gt;
之后启动虚拟机, 将VMa, VMb, VMc, VMd的ip对应改为192.168.1.2/24, 192.168.1.3/24, 192.168.1.4/24, 192.168.1.5/24.&lt;br /&gt;
用简单的ping命令就可以测试VLAN了.&lt;br /&gt;
VMa与VMc之间能够互通.&lt;br /&gt;
VMb与VMd之间能够互通.&lt;br /&gt;
但是VMa与VMb之间不能互通.&lt;br /&gt;
这样就实现了简单的VLAN..&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>linux, out of memory</title>
   <link href="http://tom.preston-werner.com/2011/12/11/linux-out-of-memory.html"/>
   <updated>2011-12-11T00:00:00+08:00</updated>
   <id>http://peerxu.github.com//2011/12/11/linux-out-of-memory</id>
   <content type="html">&lt;h2&gt;linux, out of memory&lt;/h2&gt;
&lt;p&gt;加班归来, 由于纠结了一天, 所以必须把这个给记录下来.&lt;/p&gt;
&lt;p&gt;问题是这样的, libvirt启动domain, 大概启动了20台左右, 就会发现domain们会自杀. 我就无比郁闷了, domain你们到底肿么了.&lt;/p&gt;
&lt;p&gt;经过多番查看各种log, 没有发现问题. 最后一同事发现了, 在 &lt;em&gt;/var/log/syslog&lt;/em&gt; 里面有一条关于 &lt;em&gt;kvm: out of memory&lt;/em&gt; 的log.&lt;/p&gt;
&lt;p&gt;经过各种搜索后发现, 发现在大内存的工作环境下(&amp;gt;4G), 32位的linux会产生这个错误. 但是我们觉得, 我们平常的机器都是安装64位的OS, 就没有管这个问题了. 但是问题偏偏就出现在这个OS的32位上. 所以阿, 买来的服务器还是要自己安装一次OS才行阿&amp;#8230;&lt;/p&gt;
&lt;p&gt;最后bs一下卖服务器的厂商&amp;#8230;肿么能这么装系统呢, 32位最大才索引4G内存, 一台服务器都40多G内存了.还装32位, 这不坑爹嘛!&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>在ubuntu下创建deb包</title>
   <link href="http://tom.preston-werner.com/2011/12/04/create-deb-package-on-ubuntu.html"/>
   <updated>2011-12-04T00:00:00+08:00</updated>
   <id>http://peerxu.github.com//2011/12/04/create-deb-package-on-ubuntu</id>
   <content type="html">&lt;h2&gt;在ubuntu下创建deb包&lt;/h2&gt;
&lt;p&gt;今天跟大家讲解一下如何制造自己的deb包.&lt;/p&gt;
&lt;p&gt;制造deb包的过程就是讲已经编译的库跟应用程序放到对应的目录下,之后配置一下描述你的package的文件,最后执行一个打包的命令将它打包成deb包的形式.当然你可以打包成rpm&amp;#8230;&lt;/p&gt;
&lt;p&gt;以上就是一个制造deb package的思路了.当然还有别的方法,例如使用checkinstall或者用dh_make生成需要的文件之类的.&lt;/p&gt;
&lt;p&gt;但是我用一个比较懒人的办法,就是修改已经存在的deb package.&lt;/p&gt;
&lt;h3&gt;1. 下载deb package模板&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install -d hello
$ mv /var/cache/apt/archives/hello_&amp;lt;version&amp;gt;_&amp;lt;arch&amp;gt;.deb ~/
$ cd ~
$ dpkg -X hello_&amp;lt;version&amp;gt;_&amp;lt;arch&amp;gt;.deb myhello
$ cd myhello
$ dpkg -e ../hello_&amp;lt;version&amp;gt;_&amp;lt;arch&amp;gt;.deb&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
	&lt;li&gt;首先是先把hello的deb package下载下来,但是并不安装&lt;/li&gt;
	&lt;li&gt;复制并解压文件到myhello的文件夹里面&lt;/li&gt;
	&lt;li&gt;解压deb package信息到myhello文件夹里面&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;2. 熟悉deb包结构&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ cd ~/myhello
$ tree&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;myhello的目录树结构&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.
├── DEBIAN
│   └── control
└── usr
    ├── bin
    │   └── hello
    └── share
        ├── doc
        │   └── hello
        │       ├── changelog.Debian.gz
        │       ├── copyright
        │       └── NEWS
        ├── info
        │   └── hello.info.gz
        └── man
            └── man1
                └── hello.1.gz&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;.&lt;/em&gt; 就是模拟出来的 &lt;em&gt;/&lt;/em&gt; (root)&lt;/p&gt;
&lt;p&gt;意思就是安装 &lt;em&gt;myhello&lt;/em&gt; 之后, &lt;em&gt;./usr/bin/hello&lt;/em&gt; 对应的就是复制到 &lt;em&gt;/usr/bin/hello&lt;/em&gt; 中去.&lt;/p&gt;
&lt;p&gt;之后需要讲解的就是 &lt;em&gt;./&lt;span class=&quot;caps&quot;&gt;DEBIAN&lt;/span&gt;&lt;/em&gt;目录下面的文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat ./DEBIAN/control&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;Package: hello
Version: 2.7-1
Architecture: i386
Maintainer: Ubuntu Developers &amp;lt;ubuntu-devel-discuss@lists.ubuntu.com&amp;gt;
Original-Maintainer: Santiago Vila &amp;lt;sanvila@debian.org&amp;gt;
Installed-Size: 100
Depends: libc6 (&amp;gt;= 2.4), dpkg (&amp;gt;= 1.15.4) | install-info
Section: devel
Priority: optional
Homepage: http://www.gnu.org/software/hello/
Description: The classic greeting, and a good example
 The GNU hello program produces a familiar, friendly greeting.  It
 allows non-programmers to use a classic computer science tool which
 would otherwise be unavailable to them.
 .
 Seriously, though: this is an example of how to do a Debian package.
 It is the Debian version of the GNU Project's `hello world' program
 (which is itself an example for the GNU Project).&lt;/pre&gt;
&lt;table&gt;
	&lt;tr&gt;
		&lt;td style=&quot;text-align:center;&quot;&gt;&lt;strong&gt;名称&lt;/strong&gt; &lt;/td&gt;
		&lt;td style=&quot;text-align:center;&quot;&gt;&lt;strong&gt;描述&lt;/strong&gt; &lt;/td&gt;
		&lt;td style=&quot;text-align:center;&quot;&gt;&lt;strong&gt;备注&lt;/strong&gt; &lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt; &lt;em&gt;Package&lt;/em&gt; &lt;/td&gt;
		&lt;td&gt; 包名 &lt;/td&gt;
		&lt;td&gt; &amp;nbsp; &lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt; &lt;em&gt;Version&lt;/em&gt; &lt;/td&gt;
		&lt;td&gt; 版本号 &lt;/td&gt;
		&lt;td&gt; &amp;nbsp; &lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt; &lt;em&gt;Architecture&lt;/em&gt; &lt;/td&gt;
		&lt;td&gt; 系统架构 &lt;/td&gt;
		&lt;td&gt; &amp;nbsp; &lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt; &lt;em&gt;Maintainer&lt;/em&gt; &lt;/td&gt;
		&lt;td&gt; 维护人员 &lt;/td&gt;
		&lt;td&gt; &amp;nbsp; &lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt; &lt;em&gt;Depends&lt;/em&gt; &lt;/td&gt;
		&lt;td&gt; 依赖 &lt;/td&gt;
		&lt;td&gt; &amp;nbsp; &lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt; &lt;em&gt;Priority&lt;/em&gt; &lt;/td&gt;
		&lt;td&gt; 包优先级 &lt;/td&gt;
		&lt;td&gt; 一般自制的package设置成optional就可以 &lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt; &lt;em&gt;Description&lt;/em&gt; &lt;/td&gt;
		&lt;td&gt; 描述 &lt;/td&gt;
		&lt;td&gt; 非首行时,需要输入空一个空格 &lt;/td&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;修改成你自己应用程序的信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后还有 &lt;em&gt;4&lt;/em&gt; 个文件我们需要关注的, 就就是 &lt;em&gt;preinst&lt;/em&gt; , &lt;em&gt;postinst&lt;/em&gt; , &lt;em&gt;prerm&lt;/em&gt; , &lt;em&gt;postrm&lt;/em&gt; 对应的是 &lt;em&gt;安装前&lt;/em&gt; , &lt;em&gt;安装后&lt;/em&gt; , &lt;em&gt;删除前&lt;/em&gt; , &lt;em&gt;删除后&lt;/em&gt; 对应的脚本.&lt;/p&gt;
&lt;h3&gt;替换你的应用程序到对应的目录下面&lt;/h3&gt;
&lt;p&gt;例如将我自己编译好的 &lt;em&gt;myhello&lt;/em&gt; 到 &lt;em&gt;./usr/bin/myhello&lt;/em&gt; 下.&lt;/p&gt;
&lt;h3&gt;3. 打包成deb package&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ cd ~
$ dpkg -b myhello/ myhello_1.0_i386.deb&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;4. 总结&lt;/h3&gt;
&lt;p&gt;总结起来就一下几步:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;找到模板,并解压&lt;/li&gt;
	&lt;li&gt;将自己的应用程序放到对应的目录下面&lt;/li&gt;
	&lt;li&gt;修改 &lt;em&gt;control&lt;/em&gt; 文件&lt;/li&gt;
	&lt;li&gt;按照需求添加 &lt;em&gt;preinst&lt;/em&gt; &lt;em&gt;postinst&lt;/em&gt; &lt;em&gt;prerm&lt;/em&gt; &lt;em&gt;postrm&lt;/em&gt; 脚本&lt;/li&gt;
	&lt;li&gt;打包成自己的deb package!&lt;/li&gt;
&lt;/ol&gt;</content>
 </entry>
 
 <entry>
   <title>libvirtd使用证书创建连接简介(下)</title>
   <link href="http://tom.preston-werner.com/2011/12/01/libvirtd-tutorial-for-connect-domain-with-cert-2.html"/>
   <updated>2011-12-01T00:00:00+08:00</updated>
   <id>http://peerxu.github.com//2011/12/01/libvirtd-tutorial-for-connect-domain-with-cert-2</id>
   <content type="html">&lt;h2&gt;libvirtd使用证书创建连接简介(下)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;事例程序:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import libvirt
conn = libvirt.open('qemu+tls://hostname/system')
for id in conn.listDomainsID():
    dom = conn.lookupByID(id)
    print &quot;Dom %s State %s&quot; % (dom.name(), dom.info()[0])
    dom.suspend()
    print &quot;Dom %s State %s (after suspend)&quot; % (dom.name(), dom.info()[0])
    dom.resume()
    print &quot;Dom %s State %s (after resume)&quot; % (dom.name(), dom.info()[0])
    dom.destory()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;程序简单解析: 这段代码演示了如何用tls的方式连接到远程的虚拟机中,并且能够对改连接上的虚拟机操作&lt;/p&gt;
&lt;p&gt;用tls的方式创建连接的简介就这么多了,有什么不明白的可以通过以下的邮件地址跟我联系学习交流.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>libvirtd使用证书创建连接简介(上)</title>
   <link href="http://tom.preston-werner.com/2011/11/30/libvirtd-tutorial-for-connect-domain-with-cert-1.html"/>
   <updated>2011-11-30T00:00:00+08:00</updated>
   <id>http://peerxu.github.com//2011/11/30/libvirtd-tutorial-for-connect-domain-with-cert-1</id>
   <content type="html">&lt;h2&gt;libvirtd使用证书创建连接简介(上)&lt;/h2&gt;
&lt;p&gt;上集讲的是如何配置证书与证书的存放&lt;/p&gt;
&lt;p&gt;先了解一下证书的存放位置和需要注意的一些地方&lt;/p&gt;
&lt;table&gt;
	&lt;tr&gt;
		&lt;td style=&quot;text-align:center;&quot;&gt;&lt;strong&gt;位置&lt;/strong&gt; &lt;/td&gt;
		&lt;td style=&quot;text-align:center;&quot;&gt;&lt;strong&gt;安装机&lt;/strong&gt; &lt;/td&gt;
		&lt;td style=&quot;text-align:center;&quot;&gt;&lt;strong&gt;描述&lt;/strong&gt; &lt;/td&gt;
		&lt;td style=&quot;text-align:center;&quot;&gt;&lt;strong&gt;匹配域&lt;/strong&gt; &lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td style=&quot;text-align:center;&quot;&gt;/etc/pki/CA/cacert.pem &lt;/td&gt;
		&lt;td style=&quot;text-align:center;&quot;&gt;服务端 &lt;em&gt;and&lt;/em&gt; 客户端 &lt;/td&gt;
		&lt;td style=&quot;text-align:center;&quot;&gt;CA的证书 &lt;/td&gt;
		&lt;td style=&quot;text-align:center;&quot;&gt;n/a &lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td style=&quot;text-align:center;&quot;&gt;/etc/pki/libvirt/private/serverkey.pem &lt;/td&gt;
		&lt;td style=&quot;text-align:center;&quot;&gt;服务端 &lt;/td&gt;
		&lt;td style=&quot;text-align:center;&quot;&gt;服务端的私钥 &lt;/td&gt;
		&lt;td style=&quot;text-align:center;&quot;&gt;n/a &lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td style=&quot;text-align:center;&quot;&gt;/etc/pki/libvirt/servercert.pem &lt;/td&gt;
		&lt;td style=&quot;text-align:center;&quot;&gt;服务端 &lt;/td&gt;
		&lt;td style=&quot;text-align:center;&quot;&gt;由CA颁发的服务端签名证书 &lt;/td&gt;
		&lt;td style=&quot;text-align:center;&quot;&gt;服务器的hostname必须在客户端可见,并且与CommonName匹配 &lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td style=&quot;text-align:center;&quot;&gt;/etc/pki/libvirt/private/clientkey.pem &lt;/td&gt;
		&lt;td style=&quot;text-align:center;&quot;&gt;客户端 &lt;/td&gt;
		&lt;td style=&quot;text-align:center;&quot;&gt;客户端私钥 &lt;/td&gt;
		&lt;td style=&quot;text-align:center;&quot;&gt;n/a &lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td style=&quot;text-align:center;&quot;&gt;/etc/pki/libvirt/clientcert.pem &lt;/td&gt;
		&lt;td style=&quot;text-align:center;&quot;&gt;客户端 &lt;/td&gt;
		&lt;td style=&quot;text-align:center;&quot;&gt;由CA颁发的客户端签名证书 &lt;/td&gt;
		&lt;td style=&quot;text-align:center;&quot;&gt;Distinguished Name(DN)需要在access control list里面(tls_allowed_dn_list) &lt;/td&gt;
	&lt;/tr&gt;
&lt;/table&gt;
&lt;ul&gt;
	&lt;li&gt;安装 &lt;em&gt;gnults-utils&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;apt-get install guntls-bin&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
	&lt;li&gt;创建CA, &lt;span class=&quot;caps&quot;&gt;SERVER&lt;/span&gt;, CLIENT对应的证书与私钥&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;先创建三个文件,分别命名为 &lt;em&gt;ca.info&lt;/em&gt;, &lt;em&gt;server.info&lt;/em&gt;, &lt;em&gt;client.info&lt;/em&gt; 分别填上以下的内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;file: ca.info
cn = &amp;lt;CA的机构&amp;gt;
ca
cert_signing_key&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;file: server.info
organization = &amp;lt;CA的cn&amp;gt;
cn = &amp;lt;server的hostname&amp;gt;
tls_www_server
encryption_key
signing_key&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;file: client.info
country = &amp;lt;国家&amp;gt;
state = &amp;lt;省&amp;gt; 
locality = &amp;lt;市&amp;gt;
organization = &amp;lt;CA的cn&amp;gt;
cn = &amp;lt;client的hostname&amp;gt;
tls_www_client
encryption_key
signing_key&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 &lt;em&gt;cakey.pem&lt;/em&gt;, &lt;em&gt;serverkey.pem&lt;/em&gt;, &lt;em&gt;clientkey.pem&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;创建 cakey.pem
certtool --generate-privkey &amp;gt; cakey.pem&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;创建 server.pem
certtool --generate-privkey &amp;gt; serverkey.pem&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;创建 client.pem
certtool --generate-privkey &amp;gt; clientkey.pem&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建 &lt;em&gt;cacert.pem&lt;/em&gt;, &lt;em&gt;servercert.pem&lt;/em&gt;, &lt;em&gt;clientcert.pem&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;创建 cacert.pem
certtool --generate-self-signed --load-privkey cakey.pem \
	 --template ca.info --outfile cacert.pem&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;创建 servercert.pem
certtool --generate-certificate --load-privkey serverkey.pem \
  --load-ca-certificate cacert.pem --load-ca-privkey cakey.pem \
  --template server.info --outfile servercert.pem&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;创建 client.pem
certtool --generate-certificate --load-privkey clientkey.pem \
  --load-ca-certificate cacert.pem --load-ca-privkey cakey.pem \
  --template client.info --outfile clientcert.pem&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
	&lt;li&gt;将产生的私钥跟证书放到对应的主机的对应目录下面.&lt;/li&gt;
	&lt;li&gt;重启libvirtd进程&lt;br /&gt;
&lt;code&gt;libvirtd -l -d&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;配置就这样完成了,如何连接我将在下一节中描述.&lt;/p&gt;
&lt;p&gt;引用 &lt;a href=&quot;http://libvirt.org/remote.html&quot;&gt;http://libvirt.org/remote.html&lt;/a&gt;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Textile Demo</title>
   <link href="http://tom.preston-werner.com/2011/11/27/textile-demo.html"/>
   <updated>2011-11-27T00:00:00+08:00</updated>
   <id>http://peerxu.github.com//2011/11/27/textile-demo</id>
   <content type="html">&lt;h2&gt;Textile Demo&lt;/h2&gt;
&lt;p&gt;code with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_emphasized_&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;emphasized&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;code with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*strongly emphasized*&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;strongly emphasized&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;code with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* An item in a bulleted (unordered) list
* Another item in a bulleted list
** Second Level
** Second Level Items
*** Third level&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
	&lt;li&gt;An item in a bulleted (unordered) list&lt;/li&gt;
	&lt;li&gt;Another item in a bulleted list
	&lt;ul&gt;
		&lt;li&gt;Second Level&lt;/li&gt;
		&lt;li&gt;Second Level Items
		&lt;ul&gt;
			&lt;li&gt;Third level&lt;/li&gt;
		&lt;/ul&gt;&lt;/li&gt;
	&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;code with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# An item in an enumerated (ordered) list xxxxxxx
# Another item in an enumerated list yyyyyy
## Another level in an enumerated list vvvvvvvv&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
	&lt;li&gt;An item in an enumerated (ordered) list xxxxxxx&lt;/li&gt;
	&lt;li&gt;Another item in an enumerated list yyyyyy
	&lt;ol&gt;
		&lt;li&gt;Another level in an enumerated list vvvvvvvv&lt;/li&gt;
	&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;code with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;|_. Header |_. Header |_. Header |
| Cell 1 | Cell 2 | Cell 3 |
| Cell 1 | Cell 2 | Cell 3 |&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
	&lt;tr&gt;
		&lt;th&gt;Header &lt;/th&gt;
		&lt;th&gt;Header &lt;/th&gt;
		&lt;th&gt;Header &lt;/th&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt; Cell 1 &lt;/td&gt;
		&lt;td&gt; Cell 2 &lt;/td&gt;
		&lt;td&gt; Cell 3 &lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt; Cell 1 &lt;/td&gt;
		&lt;td&gt; Cell 2 &lt;/td&gt;
		&lt;td&gt; Cell 3 &lt;/td&gt;
	&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;code with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@your code here@&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;your code here&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;code with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bc. # print &quot;I love Python&quot;
say = &quot;I love Python&quot;
print say&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;# print &quot;I love Python&quot;
say = &quot;I love Python&quot;
print say&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;code with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p. &amp;lt;input type=&quot;submit&quot; value=&quot;Check me&quot; /&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Check me&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;code with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;h1(#id). An HTML first-level heading
h2. An HTML second-level heading
h3. An HTML third-level heading
h4. An HTML fourth-level heading
h5. An HTML fifth-level heading
h6. An HTML sixth-level heading&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;id&quot;&gt;An &lt;span class=&quot;caps&quot;&gt;HTML&lt;/span&gt; first-level heading&lt;br /&gt;
h2. An &lt;span class=&quot;caps&quot;&gt;HTML&lt;/span&gt; second-level heading&lt;br /&gt;
h3. An &lt;span class=&quot;caps&quot;&gt;HTML&lt;/span&gt; third-level heading&lt;br /&gt;
h4. An &lt;span class=&quot;caps&quot;&gt;HTML&lt;/span&gt; fourth-level heading&lt;br /&gt;
h5. An &lt;span class=&quot;caps&quot;&gt;HTML&lt;/span&gt; fifth-level heading&lt;br /&gt;
h6. An &lt;span class=&quot;caps&quot;&gt;HTML&lt;/span&gt; sixth-level heading&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;code with:&lt;/p&gt;
&lt;p&gt;bc.bq. This text will be enclosed in an &lt;span class=&quot;caps&quot;&gt;HTML&lt;/span&gt; blockquote element.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This text will be enclosed in an &lt;span class=&quot;caps&quot;&gt;HTML&lt;/span&gt; blockquote element.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;code with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&quot;(classname)link text(title tooltip)&quot;:link_address&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;link_address&quot; class=&quot;cgassname&quot; title=&quot;title tooltip&quot;&gt;link text&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;code with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&quot;(classname)link text(title tooltip)&quot;:mailto:someone@example.com&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;mailto:someone@example.com&quot; class=&quot;classname&quot; title=&quot;title tooltip&quot;&gt;link text&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;code with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;!imageurl(alt text)!&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;imageurl&quot; title=&quot;alt text&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;Textile Reference&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://redcloth.org/hobix.com/textile/quick.html&quot;&gt;Textile Quick Reference&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://redcloth.org/textile/html-integration-and-escapement/&quot;&gt;Textile Reference Manual&lt;/a&gt;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Hello World</title>
   <link href="http://tom.preston-werner.com/2011/11/27/hello-world.html"/>
   <updated>2011-11-27T00:00:00+08:00</updated>
   <id>http://peerxu.github.com//2011/11/27/hello-world</id>
   <content type="html">&lt;h1&gt;Hello World&lt;/h1&gt;

&lt;p&gt;My first page, Hello World.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Peer Studio Blog的来源</title>
   <link href="http://tom.preston-werner.com/2011/11/27/about-this-blog.html"/>
   <updated>2011-11-27T00:00:00+08:00</updated>
   <id>http://peerxu.github.com//2011/11/27/about-this-blog</id>
   <content type="html">&lt;h2&gt;Peer Studio Blog的来源&lt;/h2&gt;
&lt;p&gt;创建一个博客的构思在很久之前已经有了,但是以前有鉴于自信,或是过分自信的原因,很多知识都存放在我的个人磁盘中(大脑).但是最近发现年老的缘故,记忆也开始变得不可靠了.所以这个博客就在捣腾中诞生了.&lt;/p&gt;
&lt;p&gt;此博客构建的基础是github pages.暂时是存放在 &lt;a href=&quot;http://peerxu.github.com/&quot;&gt;http://peerxu.github.com/&lt;/a&gt; 上.&lt;/p&gt;
&lt;p&gt;使用的模板是根据 &lt;a href=&quot;http://mojombo.github.com&quot;&gt;mojombo.github.com&lt;/a&gt; 的风格而成的.&lt;/p&gt;
&lt;p&gt;喜欢的话就fork me吧.&lt;/p&gt;
&lt;p&gt;暂时就写这么多吧, 我会努力丰富这个小博客的!&lt;/p&gt;</content>
 </entry>
 
 
</feed>
