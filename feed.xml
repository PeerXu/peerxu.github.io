<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>PeerStudio</title>
    <description>我的世界</description>
    <link>http://blog.e3rp4y.me/</link>
    <atom:link href="http://blog.e3rp4y.me/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>在C中调用Python程序(II)</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;承上启下的段落&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.e3rp4y.me/2015/08/07/call-python-from-c-I/&quot;&gt;上一节&lt;/a&gt;我们已经介绍了, 怎么在C语言中, 采用Python API调用Python程序.&lt;/p&gt;

&lt;p&gt;上一节采用的是&lt;code&gt;PyRun_SimpleString&lt;/code&gt;这个API函数.&lt;/p&gt;

&lt;p&gt;这个函数的优点就是方便, 不用初始化环境变量就能够正常运行了.&lt;/p&gt;

&lt;p&gt;缺点也是相当明显, 便利带来的就是灵活性不够高. 最简单的C-Python交互都无法正常完成.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;摊开你的双手, 来迎接新挑战吧!&lt;/h2&gt;

&lt;p&gt;首先, 我们还是得先看看文档.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/veryhigh.html&quot;&gt;The Very High Level Layer&lt;/a&gt;告诉我们, 除了&lt;code&gt;PyRun_SimpleString&lt;/code&gt;之外, 还有&lt;code&gt;PyRun_String&lt;/code&gt;, &lt;code&gt;PyRun_File&lt;/code&gt;, etc.&lt;/p&gt;

&lt;p&gt;我们今天就来介绍一下&lt;code&gt;PyRun_String&lt;/code&gt;的用法.&lt;/p&gt;

&lt;p&gt;这个是&lt;code&gt;PyRun_String&lt;/code&gt;的函数签名:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PyObject*             // PyRun_String的返回值类型
PyRun_String(         // 函数名
  const char *str,    // 执行的Python代码
  int start,          // 载入类型, 分别有: Py_eval_input, Py_file_input, Py_single_input
  PyObject *globals,  // 全局对象
  PyObject *locals    // 局部对象
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面我们可以知道, &lt;code&gt;PyRun_String&lt;/code&gt;和&lt;code&gt;PyRun_SimpleString&lt;/code&gt;是相似的功能, 都是运行一段Python代码.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;start&lt;/code&gt;参数是指执行的这段代码, 到底是怎么导入的, 这里分了三种模式:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/veryhigh.html?highlight=py_single_input#c.Py_eval_input&quot;&gt;Py_eval_input&lt;/a&gt;, 是执行隔离的表达式用的.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/veryhigh.html?highlight=py_single_input#c.Py_file_input&quot;&gt;Py_file_input&lt;/a&gt;, 是最常用的模式, 表示表达式&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/veryhigh.html?highlight=py_single_input#c.Py_single_input&quot;&gt;Py_single_input&lt;/a&gt;, 这种模式, 是表示输入的代码是从交互接口输入的.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;globals&lt;/code&gt;参数是表示Python的&lt;code&gt;globals&lt;/code&gt;对象&lt;/p&gt;

&lt;p&gt;&lt;code&gt;locals&lt;/code&gt;参数是表示Python的&lt;code&gt;locals&lt;/code&gt;对象&lt;/p&gt;

&lt;p&gt;好了, 了解了&lt;code&gt;PyRun_String&lt;/code&gt;函数的各个变量含义后, 我们就来写点代码吧.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;代码解析&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;// file: py.c

#include &amp;lt;python2.7/Python.h&amp;gt;

int main() {
  // 这里声明了三个环境变量和一个返回值.
  PyObject *pMainModule,   // __main__模块的指针对象, 等下会初始化为__main__模块.
      *pGlobalDict,        // globals对象指针
      *pLocalDict,         // locals对象指针
      *pResult;            // 用来获取返回值

  // 这是一段Python代码          
  char *cmd = &quot;&quot;
    &quot;import math\n&quot;
    &quot;x = 3\n&quot;
    &quot;y = 2\n&quot;
    &quot;result = math.pow(x, y)&quot;;

  // 用来接受返回值
  double result;

  Py_Initialize();

  // 初始化__main__模块
  pMainModule = PyImport_AddModule(&quot;__main__&quot;);
  // 在__main__模块中获取globals对象
  pGlobalDict = PyModule_GetDict(pMainModule);
  // 初始化一个空的locals对象
  pLocalDict = PyDict_New();

  // !! 这里是整个程序的核心, 就在这里执行了cmd的Python程序
  PyRun_String(cmd, Py_file_input, pGlobalDict, pLocalDict);

  // 获取locals对象上面的result变量
  pResult = PyDict_GetItemString(pLocalDict, &quot;result&quot;);
  // 讲PyFloat类型转换成C语言的double类型
  result = PyFloat_AsDouble(pResult);

  // 释放引用计数
  Py_DECREF(pResult);
  Py_DECREF(pLocalDict);
  Py_DECREF(pGlobalDict);

  // 打印计算得出来的值
  printf(&quot;result=%lf\n&quot;, result);

  Py_Finalize();

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译一下看看结果?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -lpython2.7 -o py py.c
$ ./py
result=9.000000
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-3&quot;&gt;总结点什么吧&lt;/h2&gt;

&lt;p&gt;好吧, 上面的注释应该写得够清楚了, 还有什么不明白的话, 就是我表达能力有问题了…&lt;/p&gt;

&lt;p&gt;实在不行就回去多看看文档吧.&lt;/p&gt;

&lt;p&gt;enjoy it~&lt;/p&gt;
</description>
        <pubDate>Fri, 07 Aug 2015 00:00:00 +0800</pubDate>
        <link>http://blog.e3rp4y.me/2015/08/07/call-python-from-c-II/</link>
        <guid isPermaLink="true">http://blog.e3rp4y.me/2015/08/07/call-python-from-c-II/</guid>
      </item>
    
      <item>
        <title>在C中调用Python程序(I)</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;废话&lt;/h2&gt;

&lt;p&gt;通常, 我们会在终端上启动Python程序.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python -c &#39;print &quot;Hello, World&quot;&#39;
Hello, World
$ python hello.py
Hello, World
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是我们今天来介绍一下, 怎么在C语言中调用Python程序.&lt;/p&gt;

&lt;p&gt;&lt;del&gt;我们当然不是在C中调用&lt;code&gt;system&lt;/code&gt;这么low的方法啦&lt;/del&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;文档导读&lt;/h2&gt;

&lt;p&gt;首先, 先把我们的&lt;a href=&quot;https://docs.python.org/2/c-api/index.html&quot;&gt;官方文档&lt;/a&gt;祭出来. 让大家膜拜一下.&lt;/p&gt;

&lt;p&gt;我们先来个文档导读.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/intro.html&quot;&gt;Introduction&lt;/a&gt;是介绍Python的C语言API接口的. 大概有什么接口啦, 要怎么调用啦, 需要define什么头文件啦, etc.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/veryhigh.html&quot;&gt;he Very High Level Layer&lt;/a&gt;是我们今天的重头戏, 介绍Python的执行表达式API.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/concrete.html&quot;&gt;Concrete Objects Layer&lt;/a&gt;是介绍每种Python原生对象C API接口, 基本上就是怎么创建对象, 修改对象, 读取对象, etc.&lt;/p&gt;

&lt;p&gt;其他文档重要吗? 当然重要啊, 回去读10遍回来比看我这篇破文章靠谱多了.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;当然我们是从最简单的开始&lt;/h2&gt;

&lt;p&gt;我们先来看看这个介绍&lt;a href=&quot;https://docs.python.org/2/c-api/intro.html#embedding-python&quot;&gt;Embedding Python&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;里面详细介绍了Python初始化环境的流程, 我们先看一个最简单的环境.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// file: py.c

// 导入Python的头文件, 这里我采用的是Python2.7版本
#include &amp;lt;python2.7/Python.h&amp;gt;

int main() {
  // 初始化Python环境
  Py_Initialize();
  // 完了
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写完上面惊为天人的代码以后, 我们就来编译它.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -lpython2.7 -o py py.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-lpython2.7&lt;/code&gt;意思是告诉gcc编译器采用&lt;code&gt;python2.7&lt;/code&gt;的代码库.&lt;/p&gt;

&lt;p&gt;注意: 在编译之前请安装相应平台的python开发库.&lt;/p&gt;

&lt;p&gt;例如: ubuntu就安装&lt;code&gt;python-dev&lt;/code&gt;, centos就安装&lt;code&gt;python-devel&lt;/code&gt;, osx貌似直接&lt;code&gt;brew install python&lt;/code&gt;就可以了.&lt;/p&gt;

&lt;p&gt;编译完成后, 会生成一个&lt;code&gt;py&lt;/code&gt;的可执行文件.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $ ./py  // 当然什么都没有显示啊笨蛋!
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;bb-&quot;&gt;别bb了, 快入正题&lt;/h2&gt;

&lt;p&gt;我们上面的程序写了那么长, 然而并没有什么卵用.&lt;/p&gt;

&lt;p&gt;我们下面来点实际点的, 调用python的print来输出点什么东西.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// file: py.c

// 导入Python的头文件, 这里我采用的是Python2.7版本
#include &amp;lt;python2.7/Python.h&amp;gt;

int main() {
  // 初始化Python环境
  Py_Initialize();
  
  // 执行Python代码, 调用Python的print
  PyRun_SimpleString(&quot;print \&quot;Hello, C! -- from Python\&quot;&quot;);
  
  // 清理Python环境
  Py_Finalize();
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再编译后执行试试?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -lpython2.7 -o py py.c
$ ./py
Hello, C! -- from Python
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;bb&quot;&gt;bb完要总结点东西吧&lt;/h2&gt;

&lt;p&gt;现在我们已经能够在C里面通过Python API来创建Python运行环境和执行Python代码了.&lt;/p&gt;

&lt;p&gt;是不是如此的激动人心?&lt;/p&gt;

&lt;p&gt;但是还有一些问题我们是需要解决的, 例如, 我怎么获取Python的变量和返回值, 我怎么调用Python的函数, etc.&lt;/p&gt;

&lt;p&gt;那句话怎么说来着的?&lt;/p&gt;

&lt;p&gt;欲知后事如何, 请听下回分解!&lt;/p&gt;

&lt;p&gt;enjoy it~&lt;/p&gt;
</description>
        <pubDate>Fri, 07 Aug 2015 00:00:00 +0800</pubDate>
        <link>http://blog.e3rp4y.me/2015/08/07/call-python-from-c-I/</link>
        <guid isPermaLink="true">http://blog.e3rp4y.me/2015/08/07/call-python-from-c-I/</guid>
      </item>
    
      <item>
        <title>在Emacs上预览graphviz图</title>
        <description>&lt;p&gt;&lt;a href=&quot;http://www.graphviz.org/&quot;&gt;graphviz&lt;/a&gt;是AT&amp;amp;T发明的一个结构化图片描述语言.&lt;/p&gt;

&lt;p&gt;接下来就是介绍如何在Emacs上编辑Graphviz文件并且预览.&lt;/p&gt;

&lt;h3 id=&quot;graphviz&quot;&gt;安装Graphviz&lt;/h3&gt;

&lt;p&gt;安装Graphviz, 这里安装的是带GUI的, 不用Emacs预览的使用也能用Graphviz.app 预览.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install Caskroom/cask/graphviz
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;graphviz-dot-modeel&quot;&gt;下载graphviz-dot-mode.el&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://raw.githubusercontent.com/ppareit/graphviz-dot-mode/master/graphviz-dot-mode.el&quot;&gt;graphviz-dot-mode.el&lt;/a&gt;是Emacs的graphviz插件, 能够编译和预览graphviz图片.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd ~/.emacs.d/  // 放置在Emacs配置目录下, 你可以放在别的地方, 下面的地址跟着修改就可以了.
$ wget https://raw.githubusercontent.com/ppareit/graphviz-dot-mode/master/graphviz-dot-mode.el
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;initel&quot;&gt;在init.el中载入插件&lt;/h3&gt;

&lt;p&gt;打开&lt;code&gt;init.el&lt;/code&gt;, 在最后载入&lt;code&gt;graphviz-dot-mode.el&lt;/code&gt;插件.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat ~/.emacs.d/init.el

...
;; Graphviz Mode
;; 如果之前保存插件地址更改了, 这里也需要作出相应的修改.
(load-file &quot;~/.emacs.d/graphviz-dot-mode.el&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加后, 每次启动Emacs都会自动载入&lt;code&gt;graphviz-dot-mode.el&lt;/code&gt;这个插件了.&lt;/p&gt;

&lt;p&gt;如果不想重启Emacs的话, 可以在句末按下, &lt;code&gt;&amp;lt;C-x&amp;gt; &amp;lt;C-e&amp;gt;&lt;/code&gt; 这样就会动态载入&lt;code&gt;graphviz-dot-mode.el&lt;/code&gt;插件了.&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;品尝成功的果实&lt;/h3&gt;

&lt;p&gt;好了, 现在万事俱备, 只欠&lt;code&gt;graphviz&lt;/code&gt;了.&lt;/p&gt;

&lt;p&gt;我们随便编辑个&lt;code&gt;graphviz&lt;/code&gt;文件.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat /tmp/test.dot

digraph structs {
    node [shape=record];
    struct1 [label=&quot;&amp;lt;f0&amp;gt; left|&amp;lt;f1&amp;gt; middle|&amp;lt;f2&amp;gt; right&quot;];
    struct2 [label=&quot;&amp;lt;f0&amp;gt; one|&amp;lt;f2&amp;gt; two&quot;];
    struct3 [label=&quot;hello\nworld |{ b |{ c|&amp;lt;here&amp;gt; d|e}| f}| g | h&quot;];
    struct1: f1 -&amp;gt; struct2:f0;
    struct1: f2 -&amp;gt; struct3:here;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用Emacs打开, 然后按下 &lt;code&gt;&amp;lt;C-c c&amp;gt;&lt;/code&gt;, 这样就成功编译&lt;code&gt;test.dot&lt;/code&gt;文件.&lt;/p&gt;

&lt;p&gt;之后只需要按下 &lt;code&gt;&amp;lt;C-c p&amp;gt;&lt;/code&gt;, 就能够预览&lt;code&gt;test.dot&lt;/code&gt;编译成png的文件.&lt;/p&gt;

&lt;p&gt;enjoy it~&lt;/p&gt;

</description>
        <pubDate>Sun, 19 Jul 2015 00:00:00 +0800</pubDate>
        <link>http://blog.e3rp4y.me/2015/07/19/preview-graphviz-on-emacs/</link>
        <guid isPermaLink="true">http://blog.e3rp4y.me/2015/07/19/preview-graphviz-on-emacs/</guid>
      </item>
    
      <item>
        <title>一次无意识的DNS劫持</title>
        <description>&lt;p&gt;0x00 前言&lt;/p&gt;

&lt;p&gt;发现DNS劫持的缘由在于部署Dnsmasq的过程中, 同网段内的Windows主机的DNS地址被改变成Dnsmasq服务所在的主机IP地址. 所有就有了这篇分析报告.&lt;/p&gt;

&lt;p&gt;0x01 现象&lt;/p&gt;

&lt;p&gt;在某个子网下部署dnsmasq服务, 过了一会儿, 其他用Windows的同事就大喊: XXX, 为什么我不能上网!&lt;/p&gt;

&lt;p&gt;经过一轮排查, 发现是使用DHCP获取IP地址的Windows用户, DNS地址被改成了部署Dnsmasq服务的服务器IP地址.&lt;/p&gt;

&lt;p&gt;以为是Dnsmasq的BUG(其实还真算Dnsmasq的BUG). 那么就添加了&lt;code&gt;--port=0&lt;/code&gt;的启动参数, 表示不提供DNS服务, 然后再添加&lt;code&gt;--dhcp-option=6,114.114.114.114&lt;/code&gt;指定DNS服务器IP地址(离真相已经很近了).&lt;/p&gt;

&lt;p&gt;但是因为公司默认的DHCP并非&lt;code&gt;114.114.114.114&lt;/code&gt;, 而是某个不知名的DNS服务器地址. 所以又有人大喊为什么我的DNS变成了&lt;code&gt;114.114.114.114&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;到现在我才意识到, 问题的严重性.&lt;/p&gt;

&lt;p&gt;我成功地将DNS劫持了.&lt;/p&gt;

&lt;p&gt;别问我劫持了DNS能够做什么.&lt;/p&gt;

&lt;p&gt;0x02 分析&lt;/p&gt;

&lt;p&gt;发生劫持事件后, 我添加Dnsmasq启动参数&lt;code&gt;--no-daemon&lt;/code&gt;, 表示调试模式.&lt;/p&gt;

&lt;p&gt;然后启动通过&lt;code&gt;tcpdump -n -i eth0 -vvv port 68&lt;/code&gt;来捕捉DHCP请求.&lt;/p&gt;

&lt;p&gt;经过观察, 发现Windows DHCP 客户端会定时广播&lt;code&gt;DHCPINFORM&lt;/code&gt;, 而Dnsmasq会响应并非在&lt;code&gt;dhcp-hostsfile&lt;/code&gt;列表里面的主机. 响应的结果就是发送&lt;code&gt;DHCPACK&lt;/code&gt;. 而&lt;code&gt;DHCPACK&lt;/code&gt;上又带上了&lt;code&gt;Domain Name Server Option&lt;/code&gt;字段.&lt;/p&gt;

&lt;p&gt;所以, Windows DHCP Client会将Dnsmasq返回的DHCPACK包中带上的DNS地址设置为自己的DNS地址.&lt;/p&gt;

&lt;p&gt;0x03 结论&lt;/p&gt;

&lt;p&gt;你还敢用Windows的DHCP吗?&lt;/p&gt;

&lt;p&gt;当你无法保证所在网络绝对安全的情况下, 请手动设置DNS地址.&lt;/p&gt;
</description>
        <pubDate>Fri, 07 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://blog.e3rp4y.me/2014/11/07/dns-hijack-with-dnsmasq/</link>
        <guid isPermaLink="true">http://blog.e3rp4y.me/2014/11/07/dns-hijack-with-dnsmasq/</guid>
      </item>
    
      <item>
        <title>SQLAlchemy多对多关系使用方法</title>
        <description>&lt;p&gt;SQLAlchemy是一个Python的数据库ORM框架.&lt;/p&gt;

&lt;p&gt;多对多数据模型是比较常用的数据关系.&lt;/p&gt;

&lt;p&gt;下面采用文章(&lt;code&gt;Page&lt;/code&gt;)和标签(&lt;code&gt;Tag&lt;/code&gt;)的关系来作为介绍范例.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一篇文章可以通过多个标签来描述概要信息.&lt;/li&gt;
  &lt;li&gt;一个标签可以对应多篇文章.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;首先我们先创建两个Sqlalchemy的模型类:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Page(Base):
    __tablename__ = &#39;page&#39;
    id = Column(Integer, primary_key=True)
    name = Column(String)
    
class Tag(Base):
    __tablename__ = &#39;tag&#39;
    id = Column(Integer, primary_key=True)
    name = Column(String)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里创建了两个模型, 分别是&lt;code&gt;Page&lt;/code&gt;和&lt;code&gt;Tag&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;添加一个需求: 我们能够在&lt;code&gt;Page&lt;/code&gt;对象中直接获取关联的&lt;code&gt;Tag&lt;/code&gt;列表&lt;/p&gt;

&lt;p&gt;那么我们就需要在&lt;code&gt;Page&lt;/code&gt;模型中添加:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Page(Base):
...
    tags = relationship(&#39;Tag&#39;, secondary=association_table)
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里就通过指定&lt;code&gt;relationship&lt;/code&gt;来指定&lt;code&gt;tags&lt;/code&gt;属性是指向&lt;code&gt;Tag&lt;/code&gt;对象的, 关联规则是通过&lt;code&gt;association_table&lt;/code&gt;的关联关系.&lt;/p&gt;

&lt;p&gt;然后就是需要创建关联规则表&lt;code&gt;association_table&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;association_table = Table(
    &#39;association&#39;, Base.metadata,
    Column(&#39;page_id&#39;, Integer, ForeignKey(&#39;page.id&#39;)),
    Column(&#39;tag_id&#39;, Integer, ForeignKey(&#39;tag.id&#39;))
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里就创建一个&lt;code&gt;Page-Tag&lt;/code&gt;关联表, 通过将&lt;code&gt;page_id&lt;/code&gt;作为&lt;code&gt;Page&lt;/code&gt;对象的外键. 同理&lt;code&gt;tag_id&lt;/code&gt;作为&lt;code&gt;Tag&lt;/code&gt;对象的外键.&lt;/p&gt;

&lt;p&gt;至此, 我们已经完成多对多模型的创建.&lt;/p&gt;

&lt;p&gt;接下来就是多对多模型的CRUD了.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;page = Page(name=&#39;Python API Page&#39;)
api_tag = Tag(name=&#39;api&#39;)
python_tag = Tag(name=&#39;python&#39;)

# append tag to page
page.tags.append(api_tag)
page.tags.append(python_tag)

# read tag from page
print [tag.name for tag in page.tags]

# remove tag from page
page.tags.remove(python_tag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上就是Sqlalchemy关于多对多模型操作方式~&lt;/p&gt;

&lt;p&gt;下面贴上完整的代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import sqlalchemy as sqla
import sqlalchemy.orm as sqlorm
from sqlalchemy.ext.declarative import declarative_base as sqla_declarative_base

Base = sqla_declarative_base()
engine = sqla.create_engine(&#39;sqlite:///test.db&#39;, echo=True)

association_table = sqla.Table(
    &#39;association&#39;, Base.metadata,
    sqla.Column(&#39;page_id&#39;, sqla.Integer, sqla.ForeignKey(&#39;page.id&#39;)),
    sqla.Column(&#39;tag_id&#39;, sqla.Integer, sqla.ForeignKey(&#39;tag.id&#39;))
)

class Page(Base):
    __tablename__ = &#39;page&#39;
    id = sqla.Column(sqla.Integer, primary_key=True)
    name = sqla.Column(sqla.String)
    tags = sqlorm.relationship(&#39;Tag&#39;, secondary=association_table)

class Tag(Base):
    __tablename__ = &#39;tag&#39;
    id = sqla.Column(sqla.Integer, primary_key=True)
    name = sqla.Column(sqla.String)
    pages = sqlorm.relationship(&#39;Page&#39;, secondary=association_table)

Base.metadata.bind = engine
Base.metadata.create_all()

Session = sqlorm.scoped_session(sqlorm.sessionmaker(bind=engine))

def save_page():
    sess = Session()
    try:
        page = Page(name=&#39;Python API Page&#39;)
        sess.add(page)

        sess.flush()
        sess.commit()
    finally:
        sess.close()

def add_tag():
   sess = Session()
   try:
       python_tag = Tag(name=&#39;python&#39;)
       api_tag = Tag(name=&#39;api&#39;)
       sess.add(python_tag)
       sess.add(api_tag)
       page = sess.query(Page).first()
       page.tags.append(python_tag)
       page.tags.append(api_tag)

       sess.flush()
       sess.commit()
   finally:
       sess.close()

def remove_tag():
    sess = Session()
    try:
        page = sess.query(Page).first()
        api_tag = sess.query(Tag).filter(Tag.name==&#39;api&#39;).first()
        page.tags.remove(api_tag)
        sess.flush()
        sess.commit()
    finally:
        sess.close()

if __name__ == &#39;__main__&#39;:
    save_page()
    add_tag()
    remove_tag()
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 21 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://blog.e3rp4y.me/2014/08/21/sqlalchemy-many-to-many-relationship/</link>
        <guid isPermaLink="true">http://blog.e3rp4y.me/2014/08/21/sqlalchemy-many-to-many-relationship/</guid>
      </item>
    
      <item>
        <title>老板, 要挑个号码么?</title>
        <description>&lt;p&gt;0x00&lt;/p&gt;

&lt;p&gt;注意: 本文仅仅探讨技术, 读者任何行为与本文无关&lt;/p&gt;

&lt;p&gt;注意: 本文探讨技术已经通过正规渠道报告&lt;/p&gt;

&lt;p&gt;0x01&lt;/p&gt;

&lt;p&gt;本文讲的是如何在阿里移动中随意挑选喜好的号码&lt;/p&gt;

&lt;p&gt;0x02&lt;/p&gt;

&lt;p&gt;挑选的几个条件:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;号码必须存在阿里移动后台&lt;/li&gt;
  &lt;li&gt;号码必须没有被别的用户购买&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;0x03&lt;/p&gt;

&lt;p&gt;改dom大法&lt;/p&gt;

&lt;p&gt;0x04&lt;/p&gt;

&lt;p&gt;enjoy yourself.&lt;/p&gt;
</description>
        <pubDate>Tue, 08 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://blog.e3rp4y.me/2014/07/08/choose-your-favorite-number-from-alibaba/</link>
        <guid isPermaLink="true">http://blog.e3rp4y.me/2014/07/08/choose-your-favorite-number-from-alibaba/</guid>
      </item>
    
      <item>
        <title>Google IP Explorer使用教程</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;教程&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/PeerXu/google-ip-explorer&quot;&gt;Google IP Explorer&lt;/a&gt;是一个查找Google IP列表的工具. 可以单独使用, 也可以配合Goagent使用.&lt;/p&gt;

&lt;p&gt;如果已经安装了gevent库, 那么可以大大地增加查找速度.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/PeerXu/google-ip-explorer.git
$ cd google-ip-explorer
$ python google.py input.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Google IP列表就在output.txt文件中.&lt;/p&gt;

&lt;p&gt;如果你需要直接使用, 那么就挑一个IP直接在浏览器里面就能使用了.&lt;/p&gt;

&lt;p&gt;如果你需要和Goagent配合使用的话, 那么就将&lt;code&gt;proxy.ini&lt;/code&gt; 下的&lt;code&gt;[iplist]&lt;/code&gt; 下的&lt;code&gt;google_cn&lt;/code&gt; 和 &lt;code&gt;google_hk&lt;/code&gt; 替换为output.txt的内容就可以了~&lt;/p&gt;
</description>
        <pubDate>Thu, 03 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://blog.e3rp4y.me/2014/07/03/google-ip-explorer-tutorial/</link>
        <guid isPermaLink="true">http://blog.e3rp4y.me/2014/07/03/google-ip-explorer-tutorial/</guid>
      </item>
    
      <item>
        <title>在浏览器中调用RESTful API Service</title>
        <description>&lt;p&gt;&lt;strong&gt;以下内容请自备梯子&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/REST&quot;&gt;RESTful&lt;/a&gt; API Service是以REST风格提供的API Service.&lt;/p&gt;

&lt;p&gt;通常情况下会采用到HTTP的GET, POST, DELETE, PUT等方法.&lt;/p&gt;

&lt;p&gt;因为浏览器的正常访问手段(直接通过连接访问或Form提交), 无法向Service发起DELETE, PUT等方法的请求.&lt;/p&gt;

&lt;p&gt;所以只能通过&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;对象来提供完整交互操作.&lt;/p&gt;

&lt;p&gt;那么最后的问题就回归到, 如果使用&lt;code&gt;XMLHttpRequest&lt;/code&gt;对象上了.&lt;/p&gt;

&lt;p&gt;参考上面给出的&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;的链接, 我们学习到使用方法.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// javascript
var xhr = new XMLHttpRequest();
xhr.open(&quot;DELETE&quot;, &quot;http://localhost:8888/messages/1&quot;);
xhr.send();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面就是&lt;code&gt;XMLHttpRequest&lt;/code&gt;的简单使用方法. 当然, 这里只是发送了, 并完成后续的处理. 我们现在只关心发送.&lt;/p&gt;

&lt;p&gt;那么在这里也奉上Server端的源代码.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#! /usr/bin/env python2.7
# filename: app.py

from flask import Flask, make_response

app = Flask(__name__)

@app.route(&#39;/messages/&amp;lt;int:msg_id&amp;gt;&#39;, methods=[&#39;DELETE&#39;])
def delete_message(msg_id):
  return &#39;delete message #%s&#39; % msg_id

app.run(debug=True, port=8888)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面就是服务端的代码.&lt;/p&gt;

&lt;p&gt;但是通过浏览器console发起请求的时候, 我们可以观察到一下错误提示:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;OPTIONS http://localhost:8888/messages/1 No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. Origin &#39;https://developer.mozilla.org&#39; is therefore not allowed access.
XMLHttpRequest cannot load http://localhost:8888/messages/1. No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. Origin &#39;https://developer.mozilla.org&#39; is therefore not allowed access.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两行错误提示表明, 我们需要在服务端上, 在返回&lt;code&gt;Response&lt;/code&gt;对象时候, 在&lt;code&gt;Response Header&lt;/code&gt;上提供&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;字段.&lt;/p&gt;

&lt;p&gt;并且通过Chrome Developer Tools的Network中观察到, &lt;code&gt;XMLHttpRequest&lt;/code&gt;会发送HTTP的&lt;code&gt;OPTIONS&lt;/code&gt; Request到服务端上. 通过这次Request的Response的&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;和&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;这两个字段来决定, xhr是否有对该域发起请求的权限.&lt;/p&gt;

&lt;p&gt;其中, &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;字段代表的是, 是否允许本域向API Service发起请求. &lt;code&gt;*&lt;/code&gt;代表所有域都能发起请求.&lt;/p&gt;

&lt;p&gt;而&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;则代表的允许请求的方法有那些.&lt;/p&gt;

&lt;p&gt;那么这时我们就&lt;strong&gt;将就地&lt;/strong&gt;添加&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;字段为&lt;code&gt;*&lt;/code&gt; **(注意: 请在生产环境中谨慎添加允许跨域的主机), 添加&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;字段为&lt;code&gt;POST,DELETE,PUT,GET&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;再次修改服务端代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#! /usr/bin/env python2.7
# filename: app.py

from flask import Flask, make_response

app = Flask(__name__)

@app.route(&#39;/messages/&amp;lt;int:msg_id&amp;gt;&#39;, methods=[&#39;OPTIONS&#39;])
def options_message(msg_id):
  resp = make_response(&#39;&#39;)
  resp.headers.extend({
      &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
      &#39;Access-Control-Allow-Methods&#39;: &#39;POST,DELETE,PUT,GET&#39;
  })
  return resp

@app.route(&#39;/messages/&amp;lt;int:msg_id&amp;gt;&#39;, methods=[&#39;DELETE&#39;])
def delete_message(msg_id):
  resp = make_response(&#39;delete message #%s&#39; % msg_id)
  resp.headers[&#39;Access-Control-Allow-Origin&#39;] = &#39;*&#39;
  return resp

app.run(debug=True, port=8888)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;OPTIONS&lt;/code&gt;处理函数中, 添加Response Header的&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;和&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;字段. 来声明权限和允许的方法.&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;DELETE&lt;/code&gt;处理函数中, 添加&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;字段来声明权限.&lt;/p&gt;

&lt;p&gt;that’s all.&lt;/p&gt;
</description>
        <pubDate>Thu, 12 Jun 2014 00:00:00 +0800</pubDate>
        <link>http://blog.e3rp4y.me/2014/06/12/send-request-to-restful-api-service-from-browser/</link>
        <guid isPermaLink="true">http://blog.e3rp4y.me/2014/06/12/send-request-to-restful-api-service-from-browser/</guid>
      </item>
    
      <item>
        <title>采用Flask-Restful插件返回Javascript脚本的两种方法</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://github.com/mitsuhiko/flask&quot;&gt;Flask&lt;/a&gt; 是Python的一个轻量级的Web框架.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/twilio/flask-restful&quot;&gt;Flask-Restful&lt;/a&gt; 是将Flask应用构建为Restful API的一个插件.&lt;/p&gt;

&lt;p&gt;一个Flask-Restful插件的demo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat app.py
#! /usr/bin/env python2.7
# filename: app.py

from flask import Flask
from flask.ext.restful import Api, Resource

app = Flask(__name__)
api = Api(app)

class User(Resource):
  def get(self, user_id):
    return {&#39;user_id&#39;: user_id}

api.add_resource(User, &#39;/users/&amp;lt;int:user_id&amp;gt;&#39;)

if __name__ == &#39;__main__&#39;:
  app.run(port=8888, debug=True)

$ python app.py
 * Running on http://127.0.0.1:8888/
 * Restarting with reloader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们可以看见Flask Demo已经成功运行.&lt;/p&gt;

&lt;p&gt;我们可以通过&lt;code&gt;curl&lt;/code&gt;这个工具来进行简单测试.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -v http://localhost:8888/users/1
* Adding handle: conn: 0x22f5a40
* Adding handle: send: 0
* Adding handle: recv: 0
* Curl_addHandleToPipeline: length: 1
* - Conn 0 (0x22f5a40) send_pipe: 1, recv_pipe: 0
* About to connect() to localhost port 8888 (#0)
*   Trying 127.0.0.1...
* Connected to localhost (127.0.0.1) port 8888 (#0)
&amp;gt; GET /users/1 HTTP/1.1
&amp;gt; User-Agent: curl/7.32.0
&amp;gt; Host: localhost:8888
&amp;gt; Accept: */*
&amp;gt;
* HTTP 1.0, assume close after body
&amp;lt; HTTP/1.0 200 OK
&amp;lt; Content-Type: application/json
&amp;lt; Content-Length: 21
&amp;lt; Server: Werkzeug/0.9.4 Python/2.7.5+
&amp;lt; Date: Mon, 09 Jun 2014 15:25:42 GMT
&amp;lt;
{
    &quot;user_id&quot;: 1
}
* Closing connection 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;curl的Response部分, 包含了一些信息.&lt;/p&gt;

&lt;p&gt;其中Content-Type字段表示的是, 返回的内容是json格式的.&lt;/p&gt;

&lt;p&gt;如果我们需要返回的值是javascript脚本的话, 那么我们就需要对demo进行一些改造.&lt;/p&gt;

&lt;p&gt;有两种办法:&lt;/p&gt;

&lt;h3 id=&quot;flaskmakeresponse&quot;&gt;1. 通过Flask的make_response函数&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ cat app.py
#! /usr/bin/env python2.7
# filename: app.py

import simplejson as json
from flask import Flask, make_response
from flask.ext.restful import Api, Resource

app = Flask(__name__)
api = Api(app)

class User(Resource):
  def get(self, user_id):
    user = {&#39;user_id&#39;: user_id}
    data = json.dumps(user)
    response = make_response(data)
    response.headers.extend({
      &#39;Content-Type&#39;: &#39;application/javascript&#39;
    })
    return response

api.add_resource(User, &#39;/users/&amp;lt;int:user_id&amp;gt;&#39;)

if __name__ == &#39;__main__&#39;:
  app.run(port=8888, debug=True)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加Content-Type字段到response的headers中, 可以将返回的内容类型设置为javascript.&lt;/p&gt;

&lt;h3 id=&quot;request-headersresponse&quot;&gt;2. 通过Request Headers限制Response类型&lt;/h3&gt;

&lt;p&gt;HTTP协议中规定, 在Request Header中指定Accept字段, 可以指定客户端接受的Response类型.&lt;/p&gt;

&lt;p&gt;例如在curl中指定Accept字段:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -H &#39;Accept: application/javascript&#39; http://localhost:8888/users/1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是在Flask-Restful插件中, 貌似是不支持javascript作为返回值类型.&lt;/p&gt;

&lt;p&gt;所以我们需要做一些patch.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#! /usr/bin/env python2.7
# filename: app.py

import simplejson as json
from flask import Flask, make_response
from flask.ext.restful import Api, Resource

# monkey patch: application/javascript mimetype

from flask.ext import restful
def output_javascript(data, code, headers=None):
  response = make_response(data, code)
  response.headers.extend(headers or {})
  return response

restful.DEFAULT_REPRESENTATIONS[&#39;application/javascript&#39;] = output_javascript

# end monkey patch

app = Flask(__name__)
api = Api(app)

class User(Resource):
  def get(self, user_id):
    return {&#39;user_id&#39;: user_id}

api.add_resource(User, &#39;/users/&amp;lt;int:user_id&amp;gt;&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种方式显得更加优雅.&lt;/p&gt;

&lt;p&gt;但是需要在发起Request的时候设置Request Header的&lt;code&gt;Accept&lt;/code&gt;字段为&lt;code&gt;application/javascript&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;the end.&lt;/p&gt;
</description>
        <pubDate>Mon, 09 Jun 2014 00:00:00 +0800</pubDate>
        <link>http://blog.e3rp4y.me/2014/06/09/response-javascript-with-flask-restful-api/</link>
        <guid isPermaLink="true">http://blog.e3rp4y.me/2014/06/09/response-javascript-with-flask-restful-api/</guid>
      </item>
    
      <item>
        <title>从主机复制文件到Docker的几种方法</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://www.docker.io&quot;&gt;Docker&lt;/a&gt;是个Linux Container管理软件.&lt;/p&gt;

&lt;p&gt;今天我们来讲解一下从主机复制文件到Docker的几种方法.&lt;/p&gt;

&lt;p&gt;在分享之前, 我们看看Docker社区对这个&lt;a href=&quot;https://github.com/dotcloud/docker/issues/905&quot;&gt;问题&lt;/a&gt;的需求是有多么强(ju)烈(jin).&lt;/p&gt;

&lt;p&gt;下面开始今天高(tu)大(yuan)上(fei)的分享.&lt;/p&gt;

&lt;h3 id=&quot;build-docker-image&quot;&gt;1. 通过Build Docker Image添加文件&lt;/h3&gt;

&lt;p&gt;Docker Image是通过Dockerfile来创建的. 具体的创建过程可以参考&lt;a href=&quot;https://www.docker.io/learn/dockerfile/&quot;&gt;这里&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;我们可以在编写Dockerfile的时候, 将需要的文件通过 &lt;code&gt;ADD&lt;/code&gt; 关键字添加文件到Docker Image里面.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM 3scale/openresty

## add your supervisor openresty config
ADD openresty.conf /etc/supervisor/conf.d/

# Add your app
ADD . /var/www

CMD [&quot;supervisor&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引用自 &lt;a href=&quot;https://index.docker.io/u/3scale/openresty/&quot;&gt;3scale/openresty&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这个Dockerfile中的&lt;code&gt;ADD&lt;/code&gt; 关键字是将本机添加到Docker Image中的&lt;code&gt;/var/www&lt;/code&gt; 文件夹中.&lt;/p&gt;

&lt;h3 id=&quot;docker-run-v--volume&quot;&gt;2. 通过docker run命令的-v/–volume参数&lt;/h3&gt;

&lt;p&gt;假设我们需要将本机的/data 目录分享到Docker的/mnt 目录下, 我们可以通过这样的命令:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ touch /data/bilibala
$ docker run -v /data:/mnt -i -t ubuntu bash
root@c039a83c35d0:/# ls /mnt
bilibala
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个命令可以在启动container中绑定文件夹.&lt;/p&gt;

&lt;h3 id=&quot;api&quot;&gt;3. 通过API绑定目录&lt;/h3&gt;

&lt;p&gt;其实这个方法本质上跟2是一样的, 但是唯一不同的就是, API将&lt;code&gt;docker run&lt;/code&gt; 这个命令分成两步了, 分别是: &lt;code&gt;create_container&lt;/code&gt; 和 &lt;code&gt;start&lt;/code&gt;
在&lt;code&gt;create_container&lt;/code&gt; 中, 通过&lt;code&gt;volumes&lt;/code&gt; 参数定义需要挂载的目录.
在&lt;code&gt;start&lt;/code&gt; 中, &lt;code&gt;binds&lt;/code&gt; 参数绑定.&lt;/p&gt;

&lt;p&gt;下面是一个简单的example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python2.7
import docker
c = docker.Client()

container = c.create_container(&#39;ubunt&#39;,
                               command=&#39;bash&#39;, volumes=[&#39;/mnt&#39;],
                               tty=True, stdin_open=True)

c.start(container[&#39;Id&#39;], binds={&#39;/data&#39;:&#39;/mnt&#39;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里就创建了一个挂载了&lt;code&gt;/data&lt;/code&gt;目录的container.&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;4. 通过环境变量传递文件&lt;/h3&gt;

&lt;p&gt;这个是我自己发明的小技巧, 因为在利用&lt;code&gt;volumes&lt;/code&gt; 参数的时候, 发现docker有些不稳定. 经常无法删除. 所以就通过创建的时候通过环境变量传输文件.&lt;/p&gt;

&lt;p&gt;先将文件通过&lt;code&gt;base64&lt;/code&gt;编码, 然后通过&lt;code&gt;create_container&lt;/code&gt; 方法的 &lt;code&gt;environment&lt;/code&gt;参数传递变量到container中, 在container中再解码放入到合适的路径下即可.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;5. 总结&lt;/h3&gt;

&lt;p&gt;总的来说, 有三种不同的方式, 将host中的文件传递到container.&lt;/p&gt;

&lt;p&gt;分别是:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建Image时, 添加文件到Image&lt;/li&gt;
  &lt;li&gt;创建Container时, 通过volumes参数传递文件&lt;/li&gt;
  &lt;li&gt;创建Container时, 通过environment参数传递文件&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 23 May 2014 00:00:00 +0800</pubDate>
        <link>http://blog.e3rp4y.me/2014/05/23/copy-file-from-host-to-docker/</link>
        <guid isPermaLink="true">http://blog.e3rp4y.me/2014/05/23/copy-file-from-host-to-docker/</guid>
      </item>
    
  </channel>
</rss>
