<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>PeerStudio</title>
    <description>我的世界</description>
    <link>http://blog.e3rp4y.me/</link>
    <atom:link href="http://blog.e3rp4y.me/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Docker源代码分析 -- pull repository</title>
        <description>&lt;p&gt;本系列文章是从源代码入手分析Docker部分功能或者模块的具体实现&lt;/p&gt;

&lt;p&gt;今天我们就先来看看在我们输入了&lt;code&gt;docker pull debian&lt;/code&gt;之后到底发生了些什么事情&lt;/p&gt;

&lt;p&gt;注意: 本文是基于docker v0.5.1版本分析&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;切入点&lt;/h2&gt;

&lt;p&gt;熟悉docker的同学都知道, 我们在运行一个container之前是需要下载container的image的.&lt;/p&gt;

&lt;p&gt;我们可以通过以下的命令实现下载镜像的功能:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker pull debian
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们就可以运行基于&lt;code&gt;debian&lt;/code&gt;的容器:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -i -t --rm --name debian debian /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么现在我们就看看, 到底在&lt;code&gt;pull&lt;/code&gt;后面发生了多少不为人知的秘密.&lt;/p&gt;

&lt;p&gt;我们知道, &lt;code&gt;commands.go&lt;/code&gt;是命令行参数的入口:&lt;/p&gt;

&lt;h2 id=&quot;commandsgo&quot;&gt;commands.go:&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;CmdPull&lt;/code&gt;作为客户端的入口, 调用&lt;code&gt;utils.ParseRepositoryTag&lt;/code&gt;处理参数, 分离出&lt;code&gt;fromImage&lt;/code&gt;和&lt;code&gt;tag&lt;/code&gt;两个参数, 然后调用服务端的&lt;code&gt;/images/create&lt;/code&gt;接口.&lt;/p&gt;

&lt;h2 id=&quot;apigo&quot;&gt;api.go:&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;api.go&lt;/code&gt;作为服务端路由解析器, 将&lt;code&gt;/images/create&lt;/code&gt;转发到&lt;code&gt;PostImagesCreate&lt;/code&gt;函数上.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PostImagesCreate&lt;/code&gt;进行一些参数处理, 之后开始调用获取镜像函数&lt;code&gt;server.go/ImagePull&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;servergo&quot;&gt;server.go:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;func (srv *Server) ImagePull(localName string, tag string, out io.Writer, sf *utils.StreamFormatter, authConfig *auth.AuthConfig) error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是&lt;code&gt;ImagePull&lt;/code&gt;的方法声明.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ImagePull&lt;/code&gt;方法的重要步骤:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通过&lt;code&gt;registry.NewRegistry&lt;/code&gt;创建&lt;code&gt;Registry&lt;/code&gt;对象&lt;code&gt;r&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;为获取镜像这个行为上锁(&lt;code&gt;srv.poolAdd&lt;/code&gt;)并且在结束时释放锁(&lt;code&gt;srv.poolRemove&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;通过&lt;code&gt;registry.ResolveRepositoryName&lt;/code&gt;解析出仓库(&lt;code&gt;repository&lt;/code&gt;)结构.&lt;/li&gt;
  &lt;li&gt;通过&lt;code&gt;srv.pullRepository&lt;/code&gt;获取仓库结构.&lt;/li&gt;
  &lt;li&gt;如果失败了, 则通过&lt;code&gt;srv.pullImage&lt;/code&gt;下载镜像.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面我们继续来分析&lt;code&gt;srv.pullRepository&lt;/code&gt;和&lt;code&gt;srv.pullImage&lt;/code&gt;方法.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (srv *Server) pullRepository(r *registry.Registry, out io.Writer, localName, remoteName, askedTag, indexEp string, sf *utils.StreamFormatter) error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是&lt;code&gt;pullRepository&lt;/code&gt;的方法声明.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pullRepository&lt;/code&gt;方法的重要步骤:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通过上面创建的&lt;code&gt;Registry&lt;/code&gt;对象&lt;code&gt;r&lt;/code&gt;的方法&lt;code&gt;GetRepositoryData&lt;/code&gt;获取仓库的数据&lt;code&gt;repoData&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;这时候通过&lt;code&gt;graph&lt;/code&gt;对象的&lt;code&gt;UpdateChecksums&lt;/code&gt;方法更新仓库上所有镜像的校验码.&lt;/li&gt;
  &lt;li&gt;接下来是通过r的方法&lt;code&gt;GetRemoteTags&lt;/code&gt;获取&lt;code&gt;repoData&lt;/code&gt;的仓库列表上, 每个仓库的&lt;code&gt;tag&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;接下来会判断一下在&lt;code&gt;CmdPull&lt;/code&gt;解析到的&lt;code&gt;tag&lt;/code&gt;是否在上面的&lt;code&gt;tags&lt;/code&gt;列表上, 如果存在则下载该&lt;code&gt;tag&lt;/code&gt;和相关联的&lt;code&gt;images&lt;/code&gt;, 否则就下载所有&lt;code&gt;tag&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;接下来就是通过&lt;code&gt;srv.pullImage&lt;/code&gt;方法来下载由步骤4中指定的&lt;code&gt;tag&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;接下来我们分析一下&lt;code&gt;pullImage&lt;/code&gt;函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (srv *Server) pullImage(r *registry.Registry, out io.Writer, imgID, endpoint string, token []string, sf *utils.StreamFormatter) error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是&lt;code&gt;pullImage&lt;/code&gt;的函数声明&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pullImage&lt;/code&gt;方法的重要步骤:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通过&lt;code&gt;r.GetRemoteHistory&lt;/code&gt;获取镜像的父节点&lt;code&gt;history&lt;/code&gt;对象, &lt;em&gt;注意: 这里的父节点是包含自己的&lt;/em&gt;.&lt;/li&gt;
  &lt;li&gt;然后就是遍历&lt;code&gt;history&lt;/code&gt;对象, 逐个下载镜像相关内容.
&amp;gt; 1. 通过&lt;code&gt;r.GetRemoteImageJSON&lt;/code&gt;获取镜像的&lt;code&gt;json&lt;/code&gt;内容&lt;code&gt;imgJSON&lt;/code&gt;, 还有镜像大小&lt;code&gt;imgSize&lt;/code&gt;
&amp;gt; 1. 由&lt;code&gt;imgJSON&lt;/code&gt;通过&lt;code&gt;NewImgJSON&lt;/code&gt;方法创建&lt;code&gt;Image&lt;/code&gt;对象&lt;code&gt;img&lt;/code&gt;
&amp;gt; 1. 通过&lt;code&gt;img&lt;/code&gt;获取到镜像&lt;code&gt;layer结构&lt;/code&gt;
&amp;gt; 1. 最后通过&lt;code&gt;graph.Register&lt;/code&gt;下载并保存整个镜像的内容及其相关的上下文.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后, 我们来分析一下&lt;code&gt;graph.Register&lt;/code&gt;方法.&lt;/p&gt;

&lt;h2 id=&quot;graphgo&quot;&gt;graph.go&lt;/h2&gt;

&lt;p&gt;这是&lt;code&gt;Register&lt;/code&gt;的方法声明.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (graph *Graph) Register(layerData Archive, store bool, img *Image) error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是&lt;code&gt;Register&lt;/code&gt;方法的重要步骤:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;先通过&lt;code&gt;ValidateID&lt;/code&gt;验证一下&lt;code&gt;镜像ID&lt;/code&gt;的有效性.&lt;/li&gt;
  &lt;li&gt;通过&lt;code&gt;StoreImage&lt;/code&gt;保存下载的镜像在临时目录.&lt;/li&gt;
  &lt;li&gt;然后将下载完成的镜像保存在对应的镜像目录.&lt;/li&gt;
  &lt;li&gt;最后再添加镜像到&lt;code&gt;graph&lt;/code&gt;的缓存里面.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;that’s all&lt;/p&gt;
</description>
        <pubDate>Sun, 29 Nov 2015 00:00:00 +0800</pubDate>
        <link>http://blog.e3rp4y.me/2015/11/29/docker-source-code-analysis-pull/</link>
        <guid isPermaLink="true">http://blog.e3rp4y.me/2015/11/29/docker-source-code-analysis-pull/</guid>
      </item>
    
      <item>
        <title>利用Docker跨平台编译Windows平台的qemu-ga.exe</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;介绍&lt;/h2&gt;

&lt;p&gt;今天, 我们介绍一下怎么在Linux环境下编译Windows的可执行文件.&lt;/p&gt;

&lt;p&gt;首先, 我们要先熟悉一下&lt;a href=&quot;https://zh.wikipedia.org/wiki/MinGW&quot;&gt;mingw&lt;/a&gt;. &lt;del&gt;基本上就是一个能够编译出windows可执行文件的gcc吧.&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;其次, 我们用一个已经搭好mingw环境的docker容器来做今天的展示.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://hub.docker.com/r/e3rp4y/centos-mingw-base/&quot;&gt;centos-mingw-base&lt;/a&gt;是在&lt;a href=&quot;https://hub.docker.com/_/centos/&quot;&gt;Centos&lt;/a&gt;上构建的mingw编译环境.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://hub.docker.com/r/e3rp4y/centos-mingw-base/~/dockerfile/&quot;&gt;Dockerfile&lt;/a&gt; (&lt;a href=&quot;https://github.com/PeerXu/centos-mingw-base&quot;&gt;github&lt;/a&gt;) 可以自己添加组件.&lt;/p&gt;

&lt;h2 id=&quot;glance&quot;&gt;Glance&lt;/h2&gt;

&lt;p&gt;我们先运行一下&lt;code&gt;centos-mingw-base&lt;/code&gt;容器看看.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run --rm -t -i e3rp4y/centos-mingw-base /bin/bash

[root@4ad795647521 /]# rpm -qa|grep mingw
mingw-binutils-generic-2.25-1.el7.x86_64
mingw64-filesystem-100-1.el7.noarch
mingw32-crt-4.0.2-1.el7.noarch
mingw64-crt-4.0.2-1.el7.noarch
mingw64-headers-4.0.2-1.el7.noarch
mingw32-cpp-4.9.1-3.el7.x86_64
mingw32-gcc-4.9.1-3.el7.x86_64
mingw64-binutils-2.25-1.el7.x86_64
mingw32-pkg-config-0.28-2.el7.x86_64
mingw32-zlib-1.2.8-2.el7.noarch
mingw64-zlib-static-1.2.8-2.el7.noarch
mingw32-win-iconv-0.0.6-1.el7.noarch
mingw32-gcc-c++-4.9.1-3.el7.x86_64
mingw64-gcc-c++-4.9.1-3.el7.x86_64
mingw64-gettext-0.18.3.2-1.el7.noarch
mingw64-glib2-2.40.0-3.el7.noarch
mingw32-termcap-1.3.1-15.el7.noarch
mingw32-glib2-2.40.0-3.el7.noarch
mingw32-glib2-static-2.40.0-3.el7.noarch
mingw-filesystem-base-100-1.el7.noarch
mingw32-filesystem-100-1.el7.noarch
mingw32-winpthreads-4.0.2-1.el7.noarch
mingw64-winpthreads-4.0.2-1.el7.noarch
mingw32-headers-4.0.2-1.el7.noarch
mingw32-binutils-2.25-1.el7.x86_64
mingw64-cpp-4.9.1-3.el7.x86_64
mingw64-gcc-4.9.1-3.el7.x86_64
mingw64-pkg-config-0.28-2.el7.x86_64
mingw64-zlib-1.2.8-2.el7.noarch
mingw32-zlib-static-1.2.8-2.el7.noarch
mingw64-termcap-1.3.1-15.el7.noarch
mingw64-libffi-3.0.13-4.el7.noarch
mingw64-win-iconv-0.0.6-1.el7.noarch
mingw64-gettext-static-0.18.3.2-1.el7.noarch
mingw32-libffi-3.0.13-4.el7.noarch
mingw32-gettext-0.18.3.2-1.el7.noarch
mingw32-gettext-static-0.18.3.2-1.el7.noarch
mingw64-glib2-static-2.40.0-3.el7.noarch
[root@4ad795647521 /]#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们能够直观的看见, 安装了mingw环境的相关组件.&lt;/p&gt;

&lt;p&gt;下面我们先来简单的编译一个Windows平台的”Hello World”.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@4ad795647521 /]# cd /tmp
[root@4ad795647521 tmp]# cat hello.c
#include &amp;lt;stdio.h&amp;gt;
int main(void) {
    printf(&quot;hello world\n&quot;);
    return 0;
}
[root@4ad795647521 tmp]# i686-w64-mingw32-gcc -o hello.exe hello.c
[root@4ad795647521 tmp]# ls -lh hello.exe
-rwxr-xr-x 1 root root 54K Aug 12 10:53 hello.exe
[root@4ad795647521 tmp]# file hello.exe
hello.exe: PE32 executable (console) Intel 80386, for MS Windows
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们就成功地编译出一个windows平台 32位系统的&lt;code&gt;hello.exe&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;备注: 如果想要编译64位的话, 将编译器换成&lt;code&gt;x86_64-w64-mingw32-gcc&lt;/code&gt;即可.&lt;/p&gt;

&lt;h2 id=&quot;qemu-gaexe&quot;&gt;编译qemu-ga.exe&lt;/h2&gt;

&lt;p&gt;下面, 我们来编译一下qemu-ga.exe&lt;/p&gt;

&lt;p&gt;首先, 我们需要将源代码放置到容器里面.&lt;/p&gt;

&lt;p&gt;我们可以采用docker的&lt;code&gt;--volume&lt;/code&gt;参数.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run --rm --volume=/Users/peer/tmp/qemu-2.3.0/:/tmp/qemu -t -i e3rp4y/centos-mingw-base
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里, 我们用&lt;code&gt;--volume&lt;/code&gt;参数, 将本机的&lt;code&gt;/Users/peer/tmp/qemu-2.3.0/&lt;/code&gt;目录映射到容器的&lt;code&gt;/tmp/qemu/&lt;/code&gt;目录上.&lt;/p&gt;

&lt;p&gt;然后我们可以开始编译了.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@035df45036cc /]# cd /tmp/qemu
[root@035df45036cc qemu]# mkdir build
[root@035df45036cc qemu]# cd build
[root@035df45036cc build]# ../confug --target-list=x86_64-softmmu --cross-prefix=i686-w64-mingw32-
[root@035df45036cc build]# make V=1 VL_LDFLAGS=-Wl,--build-id qemu-ga.exe
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;拷贝走你的&lt;code&gt;qemu-ga.exe&lt;/code&gt; happy去吧.&lt;/p&gt;

&lt;p&gt;enjoy it.&lt;/p&gt;
</description>
        <pubDate>Wed, 12 Aug 2015 00:00:00 +0800</pubDate>
        <link>http://blog.e3rp4y.me/2015/08/12/cross-platform-compile-qemu-ga-with-docker/</link>
        <guid isPermaLink="true">http://blog.e3rp4y.me/2015/08/12/cross-platform-compile-qemu-ga-with-docker/</guid>
      </item>
    
      <item>
        <title>在C中调用Python程序(II)</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;承上启下的段落&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.e3rp4y.me/2015/08/07/call-python-from-c-I/&quot;&gt;上一节&lt;/a&gt;我们已经介绍了, 怎么在C语言中, 采用Python API调用Python程序.&lt;/p&gt;

&lt;p&gt;上一节采用的是&lt;code&gt;PyRun_SimpleString&lt;/code&gt;这个API函数.&lt;/p&gt;

&lt;p&gt;这个函数的优点就是方便, 不用初始化环境变量就能够正常运行了.&lt;/p&gt;

&lt;p&gt;缺点也是相当明显, 便利带来的就是灵活性不够高. 最简单的C-Python交互都无法正常完成.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;摊开你的双手, 来迎接新挑战吧!&lt;/h2&gt;

&lt;p&gt;首先, 我们还是得先看看文档.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/veryhigh.html&quot;&gt;The Very High Level Layer&lt;/a&gt;告诉我们, 除了&lt;code&gt;PyRun_SimpleString&lt;/code&gt;之外, 还有&lt;code&gt;PyRun_String&lt;/code&gt;, &lt;code&gt;PyRun_File&lt;/code&gt;, etc.&lt;/p&gt;

&lt;p&gt;我们今天就来介绍一下&lt;code&gt;PyRun_String&lt;/code&gt;的用法.&lt;/p&gt;

&lt;p&gt;这个是&lt;code&gt;PyRun_String&lt;/code&gt;的函数签名:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PyObject*             // PyRun_String的返回值类型
PyRun_String(         // 函数名
  const char *str,    // 执行的Python代码
  int start,          // 载入类型, 分别有: Py_eval_input, Py_file_input, Py_single_input
  PyObject *globals,  // 全局对象
  PyObject *locals    // 局部对象
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面我们可以知道, &lt;code&gt;PyRun_String&lt;/code&gt;和&lt;code&gt;PyRun_SimpleString&lt;/code&gt;是相似的功能, 都是运行一段Python代码.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;start&lt;/code&gt;参数是指执行的这段代码, 到底是怎么导入的, 这里分了三种模式:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/veryhigh.html?highlight=py_single_input#c.Py_eval_input&quot;&gt;Py_eval_input&lt;/a&gt;, 是执行隔离的表达式用的.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/veryhigh.html?highlight=py_single_input#c.Py_file_input&quot;&gt;Py_file_input&lt;/a&gt;, 是最常用的模式, 表示表达式&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/veryhigh.html?highlight=py_single_input#c.Py_single_input&quot;&gt;Py_single_input&lt;/a&gt;, 这种模式, 是表示输入的代码是从交互接口输入的.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;globals&lt;/code&gt;参数是表示Python的&lt;code&gt;globals&lt;/code&gt;对象&lt;/p&gt;

&lt;p&gt;&lt;code&gt;locals&lt;/code&gt;参数是表示Python的&lt;code&gt;locals&lt;/code&gt;对象&lt;/p&gt;

&lt;p&gt;好了, 了解了&lt;code&gt;PyRun_String&lt;/code&gt;函数的各个变量含义后, 我们就来写点代码吧.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;代码解析&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;// file: py.c

#include &amp;lt;python2.7/Python.h&amp;gt;

int main() {
  // 这里声明了三个环境变量和一个返回值.
  PyObject *pMainModule,   // __main__模块的指针对象, 等下会初始化为__main__模块.
      *pGlobalDict,        // globals对象指针
      *pLocalDict,         // locals对象指针
      *pResult;            // 用来获取返回值

  // 这是一段Python代码          
  char *cmd = &quot;&quot;
    &quot;import math\n&quot;
    &quot;x = 3\n&quot;
    &quot;y = 2\n&quot;
    &quot;result = math.pow(x, y)&quot;;

  // 用来接受返回值
  double result;

  Py_Initialize();

  // 初始化__main__模块
  pMainModule = PyImport_AddModule(&quot;__main__&quot;);
  // 在__main__模块中获取globals对象
  pGlobalDict = PyModule_GetDict(pMainModule);
  // 初始化一个空的locals对象
  pLocalDict = PyDict_New();

  // !! 这里是整个程序的核心, 就在这里执行了cmd的Python程序
  PyRun_String(cmd, Py_file_input, pGlobalDict, pLocalDict);

  // 获取locals对象上面的result变量
  pResult = PyDict_GetItemString(pLocalDict, &quot;result&quot;);
  // 讲PyFloat类型转换成C语言的double类型
  result = PyFloat_AsDouble(pResult);

  // 释放引用计数
  Py_DECREF(pResult);
  Py_DECREF(pLocalDict);
  Py_DECREF(pGlobalDict);

  // 打印计算得出来的值
  printf(&quot;result=%lf\n&quot;, result);

  Py_Finalize();

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译一下看看结果?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -lpython2.7 -o py py.c
$ ./py
result=9.000000
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-3&quot;&gt;总结点什么吧&lt;/h2&gt;

&lt;p&gt;好吧, 上面的注释应该写得够清楚了, 还有什么不明白的话, 就是我表达能力有问题了…&lt;/p&gt;

&lt;p&gt;实在不行就回去多看看文档吧.&lt;/p&gt;

&lt;p&gt;enjoy it~&lt;/p&gt;
</description>
        <pubDate>Fri, 07 Aug 2015 00:00:00 +0800</pubDate>
        <link>http://blog.e3rp4y.me/2015/08/07/call-python-from-c-II/</link>
        <guid isPermaLink="true">http://blog.e3rp4y.me/2015/08/07/call-python-from-c-II/</guid>
      </item>
    
      <item>
        <title>在C中调用Python程序(I)</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;废话&lt;/h2&gt;

&lt;p&gt;通常, 我们会在终端上启动Python程序.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python -c &#39;print &quot;Hello, World&quot;&#39;
Hello, World
$ python hello.py
Hello, World
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是我们今天来介绍一下, 怎么在C语言中调用Python程序.&lt;/p&gt;

&lt;p&gt;&lt;del&gt;我们当然不是在C中调用&lt;code&gt;system&lt;/code&gt;这么low的方法啦&lt;/del&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;文档导读&lt;/h2&gt;

&lt;p&gt;首先, 先把我们的&lt;a href=&quot;https://docs.python.org/2/c-api/index.html&quot;&gt;官方文档&lt;/a&gt;祭出来. 让大家膜拜一下.&lt;/p&gt;

&lt;p&gt;我们先来个文档导读.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/intro.html&quot;&gt;Introduction&lt;/a&gt;是介绍Python的C语言API接口的. 大概有什么接口啦, 要怎么调用啦, 需要define什么头文件啦, etc.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/veryhigh.html&quot;&gt;he Very High Level Layer&lt;/a&gt;是我们今天的重头戏, 介绍Python的执行表达式API.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.python.org/2/c-api/concrete.html&quot;&gt;Concrete Objects Layer&lt;/a&gt;是介绍每种Python原生对象C API接口, 基本上就是怎么创建对象, 修改对象, 读取对象, etc.&lt;/p&gt;

&lt;p&gt;其他文档重要吗? 当然重要啊, 回去读10遍回来比看我这篇破文章靠谱多了.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;当然我们是从最简单的开始&lt;/h2&gt;

&lt;p&gt;我们先来看看这个介绍&lt;a href=&quot;https://docs.python.org/2/c-api/intro.html#embedding-python&quot;&gt;Embedding Python&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;里面详细介绍了Python初始化环境的流程, 我们先看一个最简单的环境.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// file: py.c

// 导入Python的头文件, 这里我采用的是Python2.7版本
#include &amp;lt;python2.7/Python.h&amp;gt;

int main() {
  // 初始化Python环境
  Py_Initialize();
  // 完了
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写完上面惊为天人的代码以后, 我们就来编译它.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -lpython2.7 -o py py.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-lpython2.7&lt;/code&gt;意思是告诉gcc编译器采用&lt;code&gt;python2.7&lt;/code&gt;的代码库.&lt;/p&gt;

&lt;p&gt;注意: 在编译之前请安装相应平台的python开发库.&lt;/p&gt;

&lt;p&gt;例如: ubuntu就安装&lt;code&gt;python-dev&lt;/code&gt;, centos就安装&lt;code&gt;python-devel&lt;/code&gt;, osx貌似直接&lt;code&gt;brew install python&lt;/code&gt;就可以了.&lt;/p&gt;

&lt;p&gt;编译完成后, 会生成一个&lt;code&gt;py&lt;/code&gt;的可执行文件.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $ ./py  // 当然什么都没有显示啊笨蛋!
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;bb-&quot;&gt;别bb了, 快入正题&lt;/h2&gt;

&lt;p&gt;我们上面的程序写了那么长, 然而并没有什么卵用.&lt;/p&gt;

&lt;p&gt;我们下面来点实际点的, 调用python的print来输出点什么东西.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// file: py.c

// 导入Python的头文件, 这里我采用的是Python2.7版本
#include &amp;lt;python2.7/Python.h&amp;gt;

int main() {
  // 初始化Python环境
  Py_Initialize();
  
  // 执行Python代码, 调用Python的print
  PyRun_SimpleString(&quot;print \&quot;Hello, C! -- from Python\&quot;&quot;);
  
  // 清理Python环境
  Py_Finalize();
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再编译后执行试试?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -lpython2.7 -o py py.c
$ ./py
Hello, C! -- from Python
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;bb&quot;&gt;bb完要总结点东西吧&lt;/h2&gt;

&lt;p&gt;现在我们已经能够在C里面通过Python API来创建Python运行环境和执行Python代码了.&lt;/p&gt;

&lt;p&gt;是不是如此的激动人心?&lt;/p&gt;

&lt;p&gt;但是还有一些问题我们是需要解决的, 例如, 我怎么获取Python的变量和返回值, 我怎么调用Python的函数, etc.&lt;/p&gt;

&lt;p&gt;那句话怎么说来着的?&lt;/p&gt;

&lt;p&gt;欲知后事如何, 请听下回分解!&lt;/p&gt;

&lt;p&gt;enjoy it~&lt;/p&gt;
</description>
        <pubDate>Fri, 07 Aug 2015 00:00:00 +0800</pubDate>
        <link>http://blog.e3rp4y.me/2015/08/07/call-python-from-c-I/</link>
        <guid isPermaLink="true">http://blog.e3rp4y.me/2015/08/07/call-python-from-c-I/</guid>
      </item>
    
      <item>
        <title>在Emacs上预览graphviz图</title>
        <description>&lt;p&gt;&lt;a href=&quot;http://www.graphviz.org/&quot;&gt;graphviz&lt;/a&gt;是AT&amp;amp;T发明的一个结构化图片描述语言.&lt;/p&gt;

&lt;p&gt;接下来就是介绍如何在Emacs上编辑Graphviz文件并且预览.&lt;/p&gt;

&lt;h3 id=&quot;graphviz&quot;&gt;安装Graphviz&lt;/h3&gt;

&lt;p&gt;安装Graphviz, 这里安装的是带GUI的, 不用Emacs预览的使用也能用Graphviz.app 预览.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install Caskroom/cask/graphviz
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;graphviz-dot-modeel&quot;&gt;下载graphviz-dot-mode.el&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://raw.githubusercontent.com/ppareit/graphviz-dot-mode/master/graphviz-dot-mode.el&quot;&gt;graphviz-dot-mode.el&lt;/a&gt;是Emacs的graphviz插件, 能够编译和预览graphviz图片.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd ~/.emacs.d/  // 放置在Emacs配置目录下, 你可以放在别的地方, 下面的地址跟着修改就可以了.
$ wget https://raw.githubusercontent.com/ppareit/graphviz-dot-mode/master/graphviz-dot-mode.el
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;initel&quot;&gt;在init.el中载入插件&lt;/h3&gt;

&lt;p&gt;打开&lt;code&gt;init.el&lt;/code&gt;, 在最后载入&lt;code&gt;graphviz-dot-mode.el&lt;/code&gt;插件.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat ~/.emacs.d/init.el

...
;; Graphviz Mode
;; 如果之前保存插件地址更改了, 这里也需要作出相应的修改.
(load-file &quot;~/.emacs.d/graphviz-dot-mode.el&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加后, 每次启动Emacs都会自动载入&lt;code&gt;graphviz-dot-mode.el&lt;/code&gt;这个插件了.&lt;/p&gt;

&lt;p&gt;如果不想重启Emacs的话, 可以在句末按下, &lt;code&gt;&amp;lt;C-x&amp;gt; &amp;lt;C-e&amp;gt;&lt;/code&gt; 这样就会动态载入&lt;code&gt;graphviz-dot-mode.el&lt;/code&gt;插件了.&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;品尝成功的果实&lt;/h3&gt;

&lt;p&gt;好了, 现在万事俱备, 只欠&lt;code&gt;graphviz&lt;/code&gt;了.&lt;/p&gt;

&lt;p&gt;我们随便编辑个&lt;code&gt;graphviz&lt;/code&gt;文件.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat /tmp/test.dot

digraph structs {
    node [shape=record];
    struct1 [label=&quot;&amp;lt;f0&amp;gt; left|&amp;lt;f1&amp;gt; middle|&amp;lt;f2&amp;gt; right&quot;];
    struct2 [label=&quot;&amp;lt;f0&amp;gt; one|&amp;lt;f2&amp;gt; two&quot;];
    struct3 [label=&quot;hello\nworld |{ b |{ c|&amp;lt;here&amp;gt; d|e}| f}| g | h&quot;];
    struct1: f1 -&amp;gt; struct2:f0;
    struct1: f2 -&amp;gt; struct3:here;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用Emacs打开, 然后按下 &lt;code&gt;&amp;lt;C-c c&amp;gt;&lt;/code&gt;, 这样就成功编译&lt;code&gt;test.dot&lt;/code&gt;文件.&lt;/p&gt;

&lt;p&gt;之后只需要按下 &lt;code&gt;&amp;lt;C-c p&amp;gt;&lt;/code&gt;, 就能够预览&lt;code&gt;test.dot&lt;/code&gt;编译成png的文件.&lt;/p&gt;

&lt;p&gt;enjoy it~&lt;/p&gt;

</description>
        <pubDate>Sun, 19 Jul 2015 00:00:00 +0800</pubDate>
        <link>http://blog.e3rp4y.me/2015/07/19/preview-graphviz-on-emacs/</link>
        <guid isPermaLink="true">http://blog.e3rp4y.me/2015/07/19/preview-graphviz-on-emacs/</guid>
      </item>
    
      <item>
        <title>一次无意识的DNS劫持</title>
        <description>&lt;p&gt;0x00 前言&lt;/p&gt;

&lt;p&gt;发现DNS劫持的缘由在于部署Dnsmasq的过程中, 同网段内的Windows主机的DNS地址被改变成Dnsmasq服务所在的主机IP地址. 所有就有了这篇分析报告.&lt;/p&gt;

&lt;p&gt;0x01 现象&lt;/p&gt;

&lt;p&gt;在某个子网下部署dnsmasq服务, 过了一会儿, 其他用Windows的同事就大喊: XXX, 为什么我不能上网!&lt;/p&gt;

&lt;p&gt;经过一轮排查, 发现是使用DHCP获取IP地址的Windows用户, DNS地址被改成了部署Dnsmasq服务的服务器IP地址.&lt;/p&gt;

&lt;p&gt;以为是Dnsmasq的BUG(其实还真算Dnsmasq的BUG). 那么就添加了&lt;code&gt;--port=0&lt;/code&gt;的启动参数, 表示不提供DNS服务, 然后再添加&lt;code&gt;--dhcp-option=6,114.114.114.114&lt;/code&gt;指定DNS服务器IP地址(离真相已经很近了).&lt;/p&gt;

&lt;p&gt;但是因为公司默认的DHCP并非&lt;code&gt;114.114.114.114&lt;/code&gt;, 而是某个不知名的DNS服务器地址. 所以又有人大喊为什么我的DNS变成了&lt;code&gt;114.114.114.114&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;到现在我才意识到, 问题的严重性.&lt;/p&gt;

&lt;p&gt;我成功地将DNS劫持了.&lt;/p&gt;

&lt;p&gt;别问我劫持了DNS能够做什么.&lt;/p&gt;

&lt;p&gt;0x02 分析&lt;/p&gt;

&lt;p&gt;发生劫持事件后, 我添加Dnsmasq启动参数&lt;code&gt;--no-daemon&lt;/code&gt;, 表示调试模式.&lt;/p&gt;

&lt;p&gt;然后启动通过&lt;code&gt;tcpdump -n -i eth0 -vvv port 68&lt;/code&gt;来捕捉DHCP请求.&lt;/p&gt;

&lt;p&gt;经过观察, 发现Windows DHCP 客户端会定时广播&lt;code&gt;DHCPINFORM&lt;/code&gt;, 而Dnsmasq会响应并非在&lt;code&gt;dhcp-hostsfile&lt;/code&gt;列表里面的主机. 响应的结果就是发送&lt;code&gt;DHCPACK&lt;/code&gt;. 而&lt;code&gt;DHCPACK&lt;/code&gt;上又带上了&lt;code&gt;Domain Name Server Option&lt;/code&gt;字段.&lt;/p&gt;

&lt;p&gt;所以, Windows DHCP Client会将Dnsmasq返回的DHCPACK包中带上的DNS地址设置为自己的DNS地址.&lt;/p&gt;

&lt;p&gt;0x03 结论&lt;/p&gt;

&lt;p&gt;你还敢用Windows的DHCP吗?&lt;/p&gt;

&lt;p&gt;当你无法保证所在网络绝对安全的情况下, 请手动设置DNS地址.&lt;/p&gt;
</description>
        <pubDate>Fri, 07 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://blog.e3rp4y.me/2014/11/07/dns-hijack-with-dnsmasq/</link>
        <guid isPermaLink="true">http://blog.e3rp4y.me/2014/11/07/dns-hijack-with-dnsmasq/</guid>
      </item>
    
      <item>
        <title>SQLAlchemy多对多关系使用方法</title>
        <description>&lt;p&gt;SQLAlchemy是一个Python的数据库ORM框架.&lt;/p&gt;

&lt;p&gt;多对多数据模型是比较常用的数据关系.&lt;/p&gt;

&lt;p&gt;下面采用文章(&lt;code&gt;Page&lt;/code&gt;)和标签(&lt;code&gt;Tag&lt;/code&gt;)的关系来作为介绍范例.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一篇文章可以通过多个标签来描述概要信息.&lt;/li&gt;
  &lt;li&gt;一个标签可以对应多篇文章.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;首先我们先创建两个Sqlalchemy的模型类:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Page(Base):
    __tablename__ = &#39;page&#39;
    id = Column(Integer, primary_key=True)
    name = Column(String)
    
class Tag(Base):
    __tablename__ = &#39;tag&#39;
    id = Column(Integer, primary_key=True)
    name = Column(String)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里创建了两个模型, 分别是&lt;code&gt;Page&lt;/code&gt;和&lt;code&gt;Tag&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;添加一个需求: 我们能够在&lt;code&gt;Page&lt;/code&gt;对象中直接获取关联的&lt;code&gt;Tag&lt;/code&gt;列表&lt;/p&gt;

&lt;p&gt;那么我们就需要在&lt;code&gt;Page&lt;/code&gt;模型中添加:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Page(Base):
...
    tags = relationship(&#39;Tag&#39;, secondary=association_table)
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里就通过指定&lt;code&gt;relationship&lt;/code&gt;来指定&lt;code&gt;tags&lt;/code&gt;属性是指向&lt;code&gt;Tag&lt;/code&gt;对象的, 关联规则是通过&lt;code&gt;association_table&lt;/code&gt;的关联关系.&lt;/p&gt;

&lt;p&gt;然后就是需要创建关联规则表&lt;code&gt;association_table&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;association_table = Table(
    &#39;association&#39;, Base.metadata,
    Column(&#39;page_id&#39;, Integer, ForeignKey(&#39;page.id&#39;)),
    Column(&#39;tag_id&#39;, Integer, ForeignKey(&#39;tag.id&#39;))
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里就创建一个&lt;code&gt;Page-Tag&lt;/code&gt;关联表, 通过将&lt;code&gt;page_id&lt;/code&gt;作为&lt;code&gt;Page&lt;/code&gt;对象的外键. 同理&lt;code&gt;tag_id&lt;/code&gt;作为&lt;code&gt;Tag&lt;/code&gt;对象的外键.&lt;/p&gt;

&lt;p&gt;至此, 我们已经完成多对多模型的创建.&lt;/p&gt;

&lt;p&gt;接下来就是多对多模型的CRUD了.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;page = Page(name=&#39;Python API Page&#39;)
api_tag = Tag(name=&#39;api&#39;)
python_tag = Tag(name=&#39;python&#39;)

# append tag to page
page.tags.append(api_tag)
page.tags.append(python_tag)

# read tag from page
print [tag.name for tag in page.tags]

# remove tag from page
page.tags.remove(python_tag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上就是Sqlalchemy关于多对多模型操作方式~&lt;/p&gt;

&lt;p&gt;下面贴上完整的代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import sqlalchemy as sqla
import sqlalchemy.orm as sqlorm
from sqlalchemy.ext.declarative import declarative_base as sqla_declarative_base

Base = sqla_declarative_base()
engine = sqla.create_engine(&#39;sqlite:///test.db&#39;, echo=True)

association_table = sqla.Table(
    &#39;association&#39;, Base.metadata,
    sqla.Column(&#39;page_id&#39;, sqla.Integer, sqla.ForeignKey(&#39;page.id&#39;)),
    sqla.Column(&#39;tag_id&#39;, sqla.Integer, sqla.ForeignKey(&#39;tag.id&#39;))
)

class Page(Base):
    __tablename__ = &#39;page&#39;
    id = sqla.Column(sqla.Integer, primary_key=True)
    name = sqla.Column(sqla.String)
    tags = sqlorm.relationship(&#39;Tag&#39;, secondary=association_table)

class Tag(Base):
    __tablename__ = &#39;tag&#39;
    id = sqla.Column(sqla.Integer, primary_key=True)
    name = sqla.Column(sqla.String)
    pages = sqlorm.relationship(&#39;Page&#39;, secondary=association_table)

Base.metadata.bind = engine
Base.metadata.create_all()

Session = sqlorm.scoped_session(sqlorm.sessionmaker(bind=engine))

def save_page():
    sess = Session()
    try:
        page = Page(name=&#39;Python API Page&#39;)
        sess.add(page)

        sess.flush()
        sess.commit()
    finally:
        sess.close()

def add_tag():
   sess = Session()
   try:
       python_tag = Tag(name=&#39;python&#39;)
       api_tag = Tag(name=&#39;api&#39;)
       sess.add(python_tag)
       sess.add(api_tag)
       page = sess.query(Page).first()
       page.tags.append(python_tag)
       page.tags.append(api_tag)

       sess.flush()
       sess.commit()
   finally:
       sess.close()

def remove_tag():
    sess = Session()
    try:
        page = sess.query(Page).first()
        api_tag = sess.query(Tag).filter(Tag.name==&#39;api&#39;).first()
        page.tags.remove(api_tag)
        sess.flush()
        sess.commit()
    finally:
        sess.close()

if __name__ == &#39;__main__&#39;:
    save_page()
    add_tag()
    remove_tag()
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 21 Aug 2014 00:00:00 +0800</pubDate>
        <link>http://blog.e3rp4y.me/2014/08/21/sqlalchemy-many-to-many-relationship/</link>
        <guid isPermaLink="true">http://blog.e3rp4y.me/2014/08/21/sqlalchemy-many-to-many-relationship/</guid>
      </item>
    
      <item>
        <title>老板, 要挑个号码么?</title>
        <description>&lt;p&gt;0x00&lt;/p&gt;

&lt;p&gt;注意: 本文仅仅探讨技术, 读者任何行为与本文无关&lt;/p&gt;

&lt;p&gt;注意: 本文探讨技术已经通过正规渠道报告&lt;/p&gt;

&lt;p&gt;0x01&lt;/p&gt;

&lt;p&gt;本文讲的是如何在阿里移动中随意挑选喜好的号码&lt;/p&gt;

&lt;p&gt;0x02&lt;/p&gt;

&lt;p&gt;挑选的几个条件:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;号码必须存在阿里移动后台&lt;/li&gt;
  &lt;li&gt;号码必须没有被别的用户购买&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;0x03&lt;/p&gt;

&lt;p&gt;改dom大法&lt;/p&gt;

&lt;p&gt;0x04&lt;/p&gt;

&lt;p&gt;enjoy yourself.&lt;/p&gt;
</description>
        <pubDate>Tue, 08 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://blog.e3rp4y.me/2014/07/08/choose-your-favorite-number-from-alibaba/</link>
        <guid isPermaLink="true">http://blog.e3rp4y.me/2014/07/08/choose-your-favorite-number-from-alibaba/</guid>
      </item>
    
      <item>
        <title>Google IP Explorer使用教程</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;教程&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/PeerXu/google-ip-explorer&quot;&gt;Google IP Explorer&lt;/a&gt;是一个查找Google IP列表的工具. 可以单独使用, 也可以配合Goagent使用.&lt;/p&gt;

&lt;p&gt;如果已经安装了gevent库, 那么可以大大地增加查找速度.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/PeerXu/google-ip-explorer.git
$ cd google-ip-explorer
$ python google.py input.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Google IP列表就在output.txt文件中.&lt;/p&gt;

&lt;p&gt;如果你需要直接使用, 那么就挑一个IP直接在浏览器里面就能使用了.&lt;/p&gt;

&lt;p&gt;如果你需要和Goagent配合使用的话, 那么就将&lt;code&gt;proxy.ini&lt;/code&gt; 下的&lt;code&gt;[iplist]&lt;/code&gt; 下的&lt;code&gt;google_cn&lt;/code&gt; 和 &lt;code&gt;google_hk&lt;/code&gt; 替换为output.txt的内容就可以了~&lt;/p&gt;
</description>
        <pubDate>Thu, 03 Jul 2014 00:00:00 +0800</pubDate>
        <link>http://blog.e3rp4y.me/2014/07/03/google-ip-explorer-tutorial/</link>
        <guid isPermaLink="true">http://blog.e3rp4y.me/2014/07/03/google-ip-explorer-tutorial/</guid>
      </item>
    
      <item>
        <title>在浏览器中调用RESTful API Service</title>
        <description>&lt;p&gt;&lt;strong&gt;以下内容请自备梯子&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/REST&quot;&gt;RESTful&lt;/a&gt; API Service是以REST风格提供的API Service.&lt;/p&gt;

&lt;p&gt;通常情况下会采用到HTTP的GET, POST, DELETE, PUT等方法.&lt;/p&gt;

&lt;p&gt;因为浏览器的正常访问手段(直接通过连接访问或Form提交), 无法向Service发起DELETE, PUT等方法的请求.&lt;/p&gt;

&lt;p&gt;所以只能通过&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;对象来提供完整交互操作.&lt;/p&gt;

&lt;p&gt;那么最后的问题就回归到, 如果使用&lt;code&gt;XMLHttpRequest&lt;/code&gt;对象上了.&lt;/p&gt;

&lt;p&gt;参考上面给出的&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;的链接, 我们学习到使用方法.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// javascript
var xhr = new XMLHttpRequest();
xhr.open(&quot;DELETE&quot;, &quot;http://localhost:8888/messages/1&quot;);
xhr.send();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面就是&lt;code&gt;XMLHttpRequest&lt;/code&gt;的简单使用方法. 当然, 这里只是发送了, 并完成后续的处理. 我们现在只关心发送.&lt;/p&gt;

&lt;p&gt;那么在这里也奉上Server端的源代码.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#! /usr/bin/env python2.7
# filename: app.py

from flask import Flask, make_response

app = Flask(__name__)

@app.route(&#39;/messages/&amp;lt;int:msg_id&amp;gt;&#39;, methods=[&#39;DELETE&#39;])
def delete_message(msg_id):
  return &#39;delete message #%s&#39; % msg_id

app.run(debug=True, port=8888)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面就是服务端的代码.&lt;/p&gt;

&lt;p&gt;但是通过浏览器console发起请求的时候, 我们可以观察到一下错误提示:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;OPTIONS http://localhost:8888/messages/1 No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. Origin &#39;https://developer.mozilla.org&#39; is therefore not allowed access.
XMLHttpRequest cannot load http://localhost:8888/messages/1. No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. Origin &#39;https://developer.mozilla.org&#39; is therefore not allowed access.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两行错误提示表明, 我们需要在服务端上, 在返回&lt;code&gt;Response&lt;/code&gt;对象时候, 在&lt;code&gt;Response Header&lt;/code&gt;上提供&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;字段.&lt;/p&gt;

&lt;p&gt;并且通过Chrome Developer Tools的Network中观察到, &lt;code&gt;XMLHttpRequest&lt;/code&gt;会发送HTTP的&lt;code&gt;OPTIONS&lt;/code&gt; Request到服务端上. 通过这次Request的Response的&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;和&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;这两个字段来决定, xhr是否有对该域发起请求的权限.&lt;/p&gt;

&lt;p&gt;其中, &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;字段代表的是, 是否允许本域向API Service发起请求. &lt;code&gt;*&lt;/code&gt;代表所有域都能发起请求.&lt;/p&gt;

&lt;p&gt;而&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;则代表的允许请求的方法有那些.&lt;/p&gt;

&lt;p&gt;那么这时我们就&lt;strong&gt;将就地&lt;/strong&gt;添加&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;字段为&lt;code&gt;*&lt;/code&gt; **(注意: 请在生产环境中谨慎添加允许跨域的主机), 添加&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;字段为&lt;code&gt;POST,DELETE,PUT,GET&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;再次修改服务端代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#! /usr/bin/env python2.7
# filename: app.py

from flask import Flask, make_response

app = Flask(__name__)

@app.route(&#39;/messages/&amp;lt;int:msg_id&amp;gt;&#39;, methods=[&#39;OPTIONS&#39;])
def options_message(msg_id):
  resp = make_response(&#39;&#39;)
  resp.headers.extend({
      &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
      &#39;Access-Control-Allow-Methods&#39;: &#39;POST,DELETE,PUT,GET&#39;
  })
  return resp

@app.route(&#39;/messages/&amp;lt;int:msg_id&amp;gt;&#39;, methods=[&#39;DELETE&#39;])
def delete_message(msg_id):
  resp = make_response(&#39;delete message #%s&#39; % msg_id)
  resp.headers[&#39;Access-Control-Allow-Origin&#39;] = &#39;*&#39;
  return resp

app.run(debug=True, port=8888)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;OPTIONS&lt;/code&gt;处理函数中, 添加Response Header的&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;和&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;字段. 来声明权限和允许的方法.&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;DELETE&lt;/code&gt;处理函数中, 添加&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;字段来声明权限.&lt;/p&gt;

&lt;p&gt;that’s all.&lt;/p&gt;
</description>
        <pubDate>Thu, 12 Jun 2014 00:00:00 +0800</pubDate>
        <link>http://blog.e3rp4y.me/2014/06/12/send-request-to-restful-api-service-from-browser/</link>
        <guid isPermaLink="true">http://blog.e3rp4y.me/2014/06/12/send-request-to-restful-api-service-from-browser/</guid>
      </item>
    
  </channel>
</rss>
